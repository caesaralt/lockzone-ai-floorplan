<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Takeoffs - {{ project_name }}</title>
    <!-- PDF.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
    <script>
        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js';
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            overflow: hidden;
            color: white;
        }

        .top-toolbar {
            background: linear-gradient(135deg, #16213e 0%, #0f1419 100%);
            padding: 12px 20px;
            border-bottom: 2px solid #e74c3c;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }

        .toolbar-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .project-title {
            font-size: 1.3em;
            font-weight: 700;
            color: #e74c3c;
        }

        .toolbar-actions {
            display: flex;
            gap: 10px;
        }

        .toolbar-btn {
            padding: 10px 18px;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border: 2px solid transparent;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: 600;
            transition: all 0.3s;
            white-space: nowrap;
        }

        .toolbar-btn:hover {
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            border-color: #3498db;
            transform: translateY(-2px);
        }

        .toolbar-btn.primary {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .toolbar-btn.primary:hover {
            background: linear-gradient(135deg, #c0392b 0%, #a93226 100%);
            border-color: #f39c12;
        }

        .editor-container {
            display: flex;
            height: calc(100vh - 60px);
        }

        .left-sidebar {
            width: 320px;
            background: #16213e;
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #2c3e50;
        }

        .sidebar-section {
            margin-bottom: 25px;
        }

        .sidebar-section h3 {
            color: #e74c3c;
            margin-bottom: 12px;
            font-size: 1.1em;
            border-bottom: 2px solid #e74c3c;
            padding-bottom: 6px;
        }

        .tool-button {
            display: flex;
            align-items: center;
            width: 100%;
            padding: 12px;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border: 2px solid transparent;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: 600;
            transition: all 0.3s;
        }

        .tool-button:hover {
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            border-color: #3498db;
            transform: translateX(4px);
        }

        .tool-button.active {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            border-color: #2ecc71;
        }

        .tool-button .emoji {
            font-size: 1.3em;
            margin-right: 10px;
        }

        .canvas-area {
            flex: 1;
            background: #0f1419;
            position: relative;
            overflow: auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .canvas-wrapper {
            position: relative;
            background: white;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            border-radius: 8px;
            overflow: hidden;
        }

        #floorplanCanvas {
            display: block;
            cursor: crosshair;
        }

        .right-sidebar {
            width: 380px;
            background: #16213e;
            padding: 20px;
            overflow-y: auto;
            border-left: 2px solid #2c3e50;
        }

        .price-summary {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
        }

        .price-summary h3 {
            color: white;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .price-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
            font-size: 0.95em;
        }

        .price-item:last-child {
            border-bottom: none;
            font-weight: bold;
            font-size: 1.3em;
            padding-top: 15px;
            border-top: 2px solid white;
        }

        .symbol-list {
            background: #1a252f;
            padding: 15px;
            border-radius: 8px;
            max-height: 500px;
            overflow-y: auto;
        }

        .symbol-item {
            background: #2c3e50;
            padding: 12px;
            margin-bottom: 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .symbol-item:hover {
            background: #34495e;
            border-color: #3498db;
            transform: translateX(4px);
        }

        .symbol-item.selected {
            border-color: #2ecc71;
            background: #1abc9c;
        }

        .symbol-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .symbol-id {
            font-weight: 700;
            color: #f39c12;
        }

        .symbol-type {
            color: #95a5a6;
            font-size: 0.85em;
        }

        .symbol-room {
            color: #3498db;
            font-size: 0.9em;
        }

        .edit-panel {
            background: #1a252f;
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
            border: 2px solid #e74c3c;
            display: none;
        }

        .edit-panel.active {
            display: block;
        }

        .edit-panel h3 {
            color: #e74c3c;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 6px;
            color: #ecf0f1;
            font-weight: 600;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            background: #2c3e50;
            border: 2px solid #34495e;
            border-radius: 6px;
            color: white;
            font-size: 0.95em;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #3498db;
        }

        .item-list {
            margin-top: 10px;
        }

        .item-entry {
            background: #34495e;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .item-info {
            flex: 1;
        }

        .item-name {
            font-weight: 600;
            color: #ecf0f1;
        }

        .item-price {
            color: #2ecc71;
            font-size: 0.9em;
        }

        .delete-item-btn {
            background: #e74c3c;
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85em;
        }

        .delete-item-btn:hover {
            background: #c0392b;
        }

        .add-item-btn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
            border: none;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            margin-top: 10px;
        }

        .add-item-btn:hover {
            background: linear-gradient(135deg, #229954 0%, #1e8449 100%);
        }

        .save-symbol-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            border: none;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 700;
            font-size: 1em;
            margin-top: 15px;
        }

        .save-symbol-btn:hover {
            background: linear-gradient(135deg, #2980b9 0%, #21618c 100%);
        }

        .selection-box {
            position: absolute;
            border: 2px dashed #3498db;
            background: rgba(52, 152, 219, 0.2);
            pointer-events: none;
            display: none;
        }

        .context-menu {
            position: absolute;
            background: #2c3e50;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 8px 0;
            box-shadow: 0 8px 24px rgba(0,0,0,0.5);
            display: none;
            z-index: 1000;
        }

        .context-menu-item {
            padding: 10px 20px;
            cursor: pointer;
            color: white;
            font-size: 0.95em;
        }

        .context-menu-item:hover {
            background: #34495e;
        }

        .measurement-display {
            position: absolute;
            background: rgba(44, 62, 80, 0.95);
            color: #f39c12;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 600;
            pointer-events: none;
            display: none;
        }

        .annotation {
            position: absolute;
            background: rgba(231, 76, 60, 0.95);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.85em;
            cursor: move;
            border: 2px solid #c0392b;
        }

        .color-swatch {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .color-swatch:hover {
            transform: scale(1.15);
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }

        .color-swatch.selected {
            border-color: #ffffff;
            box-shadow: 0 0 12px rgba(255,255,255,0.8);
        }

        @media (max-width: 1400px) {
            .left-sidebar,
            .right-sidebar {
                width: 280px;
            }
        }
    </style>
</head>
<body>
    <div class="top-toolbar">
        <div class="toolbar-left">
            <div class="project-title">üé® {{ project_name }} - Interactive Takeoffs</div>
        </div>
        <div class="toolbar-actions">
            <div class="page-controls" id="pageControls" style="display: none; margin-right: 12px; padding: 8px 12px; background: rgba(0,0,0,0.3); border-radius: 6px; border: 1px solid #3498db;">
                <button class="zoom-btn" id="prevPage" onclick="changePage(currentPage - 1)" style="background: #2c3e50; border: none; color: white; width: 32px; height: 32px; border-radius: 4px; cursor: pointer; font-size: 16px; margin: 0 4px;">‚óÄ</button>
                <span style="color: white; font-size: 0.9em;">Page <input type="number" id="pageInput" value="1" min="1" max="1" onchange="jumpToPage(this.value)" style="width: 50px; padding: 4px; background: #2c3e50; border: 1px solid #34495e; border-radius: 4px; color: white; text-align: center;"> of <span id="totalPages">1</span></span>
                <button class="zoom-btn" id="nextPage" onclick="changePage(currentPage + 1)" style="background: #2c3e50; border: none; color: white; width: 32px; height: 32px; border-radius: 4px; cursor: pointer; font-size: 16px; margin: 0 4px;">‚ñ∂</button>
            </div>
            <button class="toolbar-btn" onclick="window.location.href='/quotes'">‚Üê Back to Quotes</button>
            <button class="toolbar-btn" onclick="saveProgress()">üíæ Save Progress</button>
            <button class="toolbar-btn" onclick="loadProgress()">üìÇ Load</button>
            <button class="toolbar-btn" onclick="undoAction()">‚Ü∂ Undo</button>
            <button class="toolbar-btn" onclick="redoAction()">‚Ü∑ Redo</button>
            <button class="toolbar-btn" onclick="saveToMapping()">Export to Mapping Tool ‚Üí</button>
            <button class="toolbar-btn primary" onclick="exportResults()">üíæ Export & Generate Quote</button>
        </div>
    </div>

    <div class="editor-container">
        <!-- LEFT SIDEBAR: Tools -->
        <div class="left-sidebar">
            <div class="sidebar-section">
                <h3>üõ†Ô∏è Tools</h3>
                <button class="tool-button active" id="selectTool" onclick="setTool('select')">
                    <span class="emoji">üñ±Ô∏è</span> Select & Move
                </button>
                <button class="tool-button" id="placeTool" onclick="setTool('place')">
                    <span class="emoji">üìç</span> Place Symbol
                </button>
                <button class="tool-button" id="measureTool" onclick="setTool('measure')">
                    <span class="emoji">üìè</span> Measure
                </button>
                <button class="tool-button" id="annotateTool" onclick="setTool('annotate')">
                    <span class="emoji">üìù</span> Annotate
                </button>
            </div>

            <div class="sidebar-section">
                <h3>üé® Markup Tools</h3>
                <button class="tool-button" id="rectangleTool" onclick="setTool('rectangle')">
                    <span class="emoji">‚¨ú</span> Rectangle
                </button>
                <button class="tool-button" id="circleTool" onclick="setTool('circle')">
                    <span class="emoji">‚≠ï</span> Circle
                </button>
                <button class="tool-button" id="polygonTool" onclick="setTool('polygon')">
                    <span class="emoji">üî∑</span> Polygon
                </button>
                <button class="tool-button" id="freehandTool" onclick="setTool('freehand')">
                    <span class="emoji">‚úèÔ∏è</span> Freehand
                </button>

                <div style="margin-top: 12px;">
                    <label style="color: #ecf0f1; font-size: 0.9em; font-weight: 600; display: block; margin-bottom: 6px;">Markup Color:</label>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <div class="color-swatch" data-color="#e74c3c" style="background: #e74c3c;" onclick="setMarkupColor('#e74c3c')" title="Electrical"></div>
                        <div class="color-swatch" data-color="#3498db" style="background: #3498db;" onclick="setMarkupColor('#3498db')" title="Plumbing"></div>
                        <div class="color-swatch" data-color="#2ecc71" style="background: #2ecc71;" onclick="setMarkupColor('#2ecc71')" title="HVAC"></div>
                        <div class="color-swatch" data-color="#f39c12" style="background: #f39c12;" onclick="setMarkupColor('#f39c12')" title="Gas"></div>
                        <div class="color-swatch" data-color="#9b59b6" style="background: #9b59b6;" onclick="setMarkupColor('#9b59b6')" title="Data"></div>
                        <div class="color-swatch" data-color="#1abc9c" style="background: #1abc9c;" onclick="setMarkupColor('#1abc9c')" title="Security"></div>
                    </div>
                </div>
            </div>

            <div class="sidebar-section">
                <h3>‚ûï Add Symbols</h3>
                {% for key, automation in automation_data.automation_types.items() %}
                <button class="tool-button" onclick="selectSymbolType('{{ key }}', '{{ automation.name }}')">
                    <span class="emoji">{{ automation.symbols[0] }}</span> {{ automation.name }}
                </button>
                {% endfor %}
            </div>

            <div class="sidebar-section">
                <h3>‚öôÔ∏è Actions</h3>
                <button class="tool-button" onclick="deleteSelected()">
                    <span class="emoji">üóëÔ∏è</span> Delete Selected
                </button>
                <button class="tool-button" onclick="duplicateSelected()">
                    <span class="emoji">üìã</span> Duplicate Selected
                </button>
                <button class="tool-button" onclick="selectAll()">
                    <span class="emoji">‚òëÔ∏è</span> Select All
                </button>
                <button class="tool-button" onclick="clearSelection()">
                    <span class="emoji">‚úñÔ∏è</span> Clear Selection
                </button>
            </div>

            <div class="sidebar-section">
                <h3>üìä Reports</h3>
                <button class="tool-button" onclick="exportMarkupsToCSV()">
                    <span class="emoji">üìà</span> Export Markups (CSV)
                </button>
                <button class="tool-button" onclick="exportTakeoffsReport()">
                    <span class="emoji">üìã</span> Full Takeoffs Report
                </button>
            </div>

            <div class="sidebar-section">
                <h3>üí° Instructions</h3>
                <div style="font-size: 0.85em; color: #95a5a6; line-height: 1.5;">
                    <strong>AI placed symbols automatically!</strong><br><br>
                    ‚Ä¢ <strong>Click</strong> symbol to edit items & pricing<br>
                    ‚Ä¢ <strong>Drag</strong> to move symbols<br>
                    ‚Ä¢ <strong>Shift+Click</strong> to multi-select<br>
                    ‚Ä¢ <strong>Drag area</strong> to select multiple<br>
                    ‚Ä¢ <strong>Right-click</strong> for more options<br>
                    ‚Ä¢ <strong>Delete key</strong> to remove selected
                </div>
            </div>
        </div>

        <!-- CENTER: Canvas -->
        <div class="canvas-area">
            <div class="canvas-wrapper">
                <canvas id="floorplanCanvas"></canvas>
                <div class="selection-box" id="selectionBox"></div>
                <div class="measurement-display" id="measurementDisplay"></div>
            </div>
        </div>

        <!-- RIGHT SIDEBAR: Properties & Pricing -->
        <div class="right-sidebar">
            <div class="price-summary">
                <h3>üí∞ Total Pricing</h3>
                <div class="price-item">
                    <span>Subtotal:</span>
                    <span id="priceSubtotal">$0.00</span>
                </div>
                <div class="price-item">
                    <span>Markup:</span>
                    <span id="priceMarkup">$0.00</span>
                </div>
                <div class="price-item">
                    <span>TOTAL:</span>
                    <span id="priceTotal">$0.00</span>
                </div>
            </div>

            <div class="sidebar-section">
                <h3>üìã Symbols on Plan</h3>
                <div class="symbol-list" id="symbolList">
                    <!-- Dynamic symbol list -->
                </div>
            </div>

            <!-- Edit Panel -->
            <div class="edit-panel" id="editPanel">
                <h3>‚úèÔ∏è Edit Symbol: <span id="editSymbolId"></span></h3>

                <div class="form-group">
                    <label>Symbol Type</label>
                    <select id="editSymbolType">
                        {% for key, automation in automation_data.automation_types.items() %}
                        <option value="{{ key }}">{{ automation.symbols[0] }} {{ automation.name }}</option>
                        {% endfor %}
                    </select>
                </div>

                <div class="form-group">
                    <label>Custom Image (Optional)</label>
                    <input type="file" id="editSymbolImage" accept="image/*" onchange="uploadCustomImage()">
                </div>

                <div class="form-group">
                    <label>Room/Location</label>
                    <input type="text" id="editSymbolRoom" placeholder="e.g., Living Room">
                </div>

                <div class="form-group">
                    <label>Products & Items</label>
                    <div class="item-list" id="itemList">
                        <!-- Dynamic items -->
                    </div>
                    <button class="add-item-btn" onclick="showAddItemDialog()">+ Add Product/Item</button>
                </div>

                <button class="save-symbol-btn" onclick="saveSymbolChanges()">üíæ Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" onclick="editSymbolFromContext()">‚úèÔ∏è Edit Symbol</div>
        <div class="context-menu-item" onclick="duplicateFromContext()">üìã Duplicate</div>
        <div class="context-menu-item" onclick="deleteFromContext()">üóëÔ∏è Delete</div>
    </div>

    <script>
        // Session data from server
        const sessionData = {{ session_data | tojson }};
        const automationData = {{ automation_data | tojson }};
        let symbols = {{ initial_symbols | tojson }};

        // Canvas setup
        const canvas = document.getElementById('floorplanCanvas');
        const ctx = canvas.getContext('2d');
        let floorplanImage = new Image();

        // Multi-page PDF state
        let pdfDocument = null;
        let currentPage = 1;
        let totalPages = 1;
        let pageData = {}; // Store per-page symbols, annotations

        // State
        let currentTool = 'select';
        let selectedSymbols = new Set();
        let editingSymbol = null;
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let dragOffset = { x: 0, y: 0 };
        let isSelectionDrag = false;
        let measurementStart = null;
        let annotations = [];

        // Markup tools state
        let markups = [];
        let currentMarkup = null;
        let markupColor = '#e74c3c'; // Default: Electrical red
        let isDrawingMarkup = false;
        let polygonPoints = [];
        let freehandPoints = [];

        // Undo/Redo system
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO_STACK = 50;

        // Auto-save
        let autoSaveInterval = null;

        // Load floor plan image
        const floorplanFilename = sessionData.floorplan_image;
        floorplanImage.onload = function() {
            canvas.width = floorplanImage.width;
            canvas.height = floorplanImage.height;
            render();
            updateSymbolList();
            updatePricing();
        };
        floorplanImage.src = `/api/download/${floorplanFilename}`;

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw floor plan
            ctx.drawImage(floorplanImage, 0, 0);

            // Draw symbols
            symbols.forEach(symbol => {
                const x = symbol.x * canvas.width;
                const y = symbol.y * canvas.height;

                const isSelected = selectedSymbols.has(symbol.id);

                // Draw symbol based on type
                const automationType = symbol.automation_category || symbol.type;
                let color, emoji;

                switch(automationType) {
                    case 'lighting': color = '#FFD700'; emoji = 'üí°'; break;
                    case 'shading': color = '#8B4513'; emoji = 'ü™ü'; break;
                    case 'security_access': case 'security': color = '#DC143C'; emoji = 'üîê'; break;
                    case 'climate': color = '#00CED1'; emoji = 'üå°Ô∏è'; break;
                    case 'audio': color = '#9370DB'; emoji = 'üîä'; break;
                    default: color = '#808080'; emoji = '‚Ä¢'; break;
                }

                // Check if symbol has custom image
                if (symbol.custom_image_data) {
                    // Draw custom image
                    const img = new Image();
                    img.onload = function() {
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(x, y, isSelected ? 25 : 20, 0, 2 * Math.PI);
                        ctx.clip();
                        ctx.drawImage(img, x - (isSelected ? 25 : 20), y - (isSelected ? 25 : 20), (isSelected ? 50 : 40), (isSelected ? 50 : 40));
                        ctx.restore();

                        if (isSelected) {
                            ctx.beginPath();
                            ctx.arc(x, y, 25, 0, 2 * Math.PI);
                            ctx.strokeStyle = '#2ecc71';
                            ctx.lineWidth = 4;
                            ctx.stroke();
                        }
                    };
                    img.src = symbol.custom_image_data;
                } else {
                    // Draw default circle and emoji
                    ctx.beginPath();
                    ctx.arc(x, y, isSelected ? 20 : 15, 0, 2 * Math.PI);
                    ctx.strokeStyle = color;
                    ctx.lineWidth = isSelected ? 4 : 3;
                    ctx.stroke();

                    if (isSelected) {
                        ctx.fillStyle = 'rgba(46, 204, 113, 0.3)';
                        ctx.fill();
                    }

                    // Draw emoji
                    ctx.font = '20px Arial';
                    ctx.fillText(emoji, x - 10, y + 8);
                }

                // Draw label
                ctx.font = 'bold 12px Arial';
                ctx.fillStyle = color;
                ctx.fillText(symbol.id || symbol.label, x + 25, y - 10);
            });

            // Draw markups
            markups.forEach(markup => {
                ctx.strokeStyle = markup.color;
                ctx.fillStyle = markup.color + '40'; // Semi-transparent fill
                ctx.lineWidth = 3;

                if (markup.type === 'rectangle') {
                    ctx.beginPath();
                    ctx.rect(markup.x, markup.y, markup.width, markup.height);
                    ctx.fill();
                    ctx.stroke();
                } else if (markup.type === 'circle') {
                    ctx.beginPath();
                    ctx.arc(markup.centerX, markup.centerY, markup.radius, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                } else if (markup.type === 'polygon' && markup.points && markup.points.length > 0) {
                    ctx.beginPath();
                    ctx.moveTo(markup.points[0].x, markup.points[0].y);
                    for (let i = 1; i < markup.points.length; i++) {
                        ctx.lineTo(markup.points[i].x, markup.points[i].y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else if (markup.type === 'freehand' && markup.points && markup.points.length > 0) {
                    ctx.beginPath();
                    ctx.moveTo(markup.points[0].x, markup.points[0].y);
                    for (let i = 1; i < markup.points.length; i++) {
                        ctx.lineTo(markup.points[i].x, markup.points[i].y);
                    }
                    ctx.stroke();
                }
            });

            // Draw current markup being created
            if (currentMarkup) {
                ctx.strokeStyle = markupColor;
                ctx.fillStyle = markupColor + '40';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);

                if (currentMarkup.type === 'rectangle') {
                    ctx.strokeRect(currentMarkup.x, currentMarkup.y, currentMarkup.width, currentMarkup.height);
                } else if (currentMarkup.type === 'circle') {
                    ctx.beginPath();
                    ctx.arc(currentMarkup.centerX, currentMarkup.centerY, currentMarkup.radius, 0, 2 * Math.PI);
                    ctx.stroke();
                } else if (currentMarkup.type === 'polygon' && polygonPoints.length > 0) {
                    ctx.beginPath();
                    ctx.moveTo(polygonPoints[0].x, polygonPoints[0].y);
                    for (let i = 1; i < polygonPoints.length; i++) {
                        ctx.lineTo(polygonPoints[i].x, polygonPoints[i].y);
                    }
                    ctx.stroke();

                    // Draw points
                    polygonPoints.forEach(pt => {
                        ctx.fillStyle = markupColor;
                        ctx.beginPath();
                        ctx.arc(pt.x, pt.y, 5, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                } else if (currentMarkup.type === 'freehand' && freehandPoints.length > 0) {
                    ctx.beginPath();
                    ctx.moveTo(freehandPoints[0].x, freehandPoints[0].y);
                    for (let i = 1; i < freehandPoints.length; i++) {
                        ctx.lineTo(freehandPoints[i].x, freehandPoints[i].y);
                    }
                    ctx.stroke();
                }

                ctx.setLineDash([]);
            }
        }

        function updateSymbolList() {
            const list = document.getElementById('symbolList');
            list.innerHTML = '';

            symbols.forEach(symbol => {
                const div = document.createElement('div');
                div.className = 'symbol-item' + (selectedSymbols.has(symbol.id) ? ' selected' : '');
                div.onclick = () => selectSymbol(symbol.id, true);
                div.ondblclick = () => editSymbol(symbol.id);

                div.innerHTML = `
                    <div class="symbol-item-header">
                        <span class="symbol-id">${symbol.id}</span>
                        <span class="symbol-type">${symbol.automation_category || symbol.type}</span>
                    </div>
                    <div class="symbol-room">${symbol.room || 'Unassigned'}</div>
                `;

                list.appendChild(div);
            });
        }

        function updatePricing() {
            let subtotal = 0;

            symbols.forEach(symbol => {
                const automationType = symbol.automation_category || symbol.type;
                const tier = sessionData.tier || 'basic';

                if (automationData.automation_types[automationType]) {
                    const config = automationData.automation_types[automationType];
                    const unitCost = config.base_cost_per_unit[tier] || 0;
                    const laborHours = config.labor_hours[tier] || 0;
                    const laborCost = laborHours * automationData.labor_rate;

                    subtotal += unitCost + laborCost;
                }

                // Add custom items
                if (symbol.items && symbol.items.length > 0) {
                    symbol.items.forEach(item => {
                        const price = parseFloat(item.price) || 0;
                        const quantity = parseInt(item.quantity) || 1;
                        subtotal += price * quantity;
                    });
                }
            });

            const markup = subtotal * (automationData.markup_percentage / 100);
            const total = subtotal + markup;

            document.getElementById('priceSubtotal').textContent = `$${subtotal.toFixed(2)}`;
            document.getElementById('priceMarkup').textContent = `$${markup.toFixed(2)}`;
            document.getElementById('priceTotal').textContent = `$${total.toFixed(2)}`;
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(tool + 'Tool').classList.add('active');

            // Reset markup drawing state
            currentMarkup = null;
            polygonPoints = [];
            freehandPoints = [];
            isDrawingMarkup = false;

            // Update cursor
            if (tool === 'select') canvas.style.cursor = 'default';
            else if (tool === 'place') canvas.style.cursor = 'crosshair';
            else if (tool === 'measure') canvas.style.cursor = 'crosshair';
            else if (tool === 'annotate') canvas.style.cursor = 'text';
            else if (tool === 'rectangle' || tool === 'circle' || tool === 'polygon' || tool === 'freehand') {
                canvas.style.cursor = 'crosshair';
            }

            render();
        }

        function setMarkupColor(color) {
            markupColor = color;
            document.querySelectorAll('.color-swatch').forEach(swatch => {
                swatch.classList.remove('selected');
            });
            document.querySelector(`.color-swatch[data-color="${color}"]`).classList.add('selected');
            console.log(`üé® Markup color set to ${color}`);
        }

        function selectSymbolType(type, name) {
            currentTool = 'place';
            setTool('place');
            canvas.dataset.placeType = type;
            alert(`Click on the floor plan to place: ${name}`);
        }

        function selectSymbol(symbolId, scroll = false) {
            if (selectedSymbols.has(symbolId)) {
                selectedSymbols.delete(symbolId);
            } else {
                selectedSymbols.add(symbolId);
            }
            render();
            updateSymbolList();
        }

        function editSymbol(symbolId) {
            const symbol = symbols.find(s => s.id === symbolId);
            if (!symbol) return;

            editingSymbol = symbol;
            const panel = document.getElementById('editPanel');
            panel.classList.add('active');

            document.getElementById('editSymbolId').textContent = symbol.id;
            document.getElementById('editSymbolType').value = symbol.automation_category || symbol.type;
            document.getElementById('editSymbolRoom').value = symbol.room || '';

            // Populate items
            const itemList = document.getElementById('itemList');
            itemList.innerHTML = '';

            if (symbol.items && symbol.items.length > 0) {
                symbol.items.forEach((item, index) => {
                    const div = document.createElement('div');
                    div.className = 'item-entry';
                    const quantity = item.quantity || 1;
                    const price = parseFloat(item.price) || 0;
                    const total = quantity * price;
                    div.innerHTML = `
                        <div class="item-info">
                            <div class="item-name">${item.name}</div>
                            <div class="item-price">$${price.toFixed(2)} √ó ${quantity} = $${total.toFixed(2)}</div>
                        </div>
                        <button class="delete-item-btn" onclick="deleteItem(${index})">Delete</button>
                    `;
                    itemList.appendChild(div);
                });
            }
        }

        function saveSymbolChanges() {
            if (!editingSymbol) return;

            editingSymbol.automation_category = document.getElementById('editSymbolType').value;
            editingSymbol.room = document.getElementById('editSymbolRoom').value;

            render();
            updateSymbolList();
            updatePricing();

            document.getElementById('editPanel').classList.remove('active');
            editingSymbol = null;

            alert('‚úÖ Symbol updated successfully!');
        }

        function showAddItemDialog() {
            const name = prompt('Enter product/item name:');
            if (!name) return;

            const price = prompt('Enter price per unit:');
            if (!price) return;

            const quantity = prompt('Enter quantity:', '1');
            if (!quantity) return;

            if (!editingSymbol.items) editingSymbol.items = [];
            editingSymbol.items.push({
                name: name,
                price: parseFloat(price),
                quantity: parseInt(quantity) || 1
            });

            editSymbol(editingSymbol.id);
            updatePricing();
        }

        function deleteItem(index) {
            if (!editingSymbol || !editingSymbol.items) return;
            editingSymbol.items.splice(index, 1);
            editSymbol(editingSymbol.id);
            updatePricing();
        }

        function deleteSelected() {
            if (selectedSymbols.size === 0) {
                alert('No symbols selected');
                return;
            }

            if (confirm(`Delete ${selectedSymbols.size} selected symbol(s)?`)) {
                symbols = symbols.filter(s => !selectedSymbols.has(s.id));
                selectedSymbols.clear();
                render();
                updateSymbolList();
                updatePricing();
            }
        }

        function duplicateSelected() {
            if (selectedSymbols.size === 0) {
                alert('No symbols selected');
                return;
            }

            selectedSymbols.forEach(id => {
                const symbol = symbols.find(s => s.id === id);
                if (symbol) {
                    const newSymbol = { ...symbol };
                    newSymbol.id = symbol.id + '_copy_' + Date.now();
                    newSymbol.x += 0.05;
                    newSymbol.y += 0.05;
                    symbols.push(newSymbol);
                }
            });

            render();
            updateSymbolList();
            updatePricing();
        }

        function selectAll() {
            selectedSymbols.clear();
            symbols.forEach(s => selectedSymbols.add(s.id));
            render();
            updateSymbolList();
        }

        function clearSelection() {
            selectedSymbols.clear();
            render();
            updateSymbolList();
        }

        // Canvas interactions
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width * canvas.width;
            const y = (e.clientY - rect.top) / rect.height * canvas.height;
            const normX = (e.clientX - rect.left) / canvas.width;
            const normY = (e.clientY - rect.top) / canvas.height;

            if (currentTool === 'select') {
                // Check if clicking on symbol
                let clickedSymbol = null;
                symbols.forEach(symbol => {
                    const dx = (symbol.x - normX) * canvas.width;
                    const dy = (symbol.y - normY) * canvas.height;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 20) {
                        clickedSymbol = symbol;
                    }
                });

                if (clickedSymbol) {
                    if (e.shiftKey) {
                        selectSymbol(clickedSymbol.id);
                    } else {
                        if (!selectedSymbols.has(clickedSymbol.id)) {
                            selectedSymbols.clear();
                            selectedSymbols.add(clickedSymbol.id);
                            render();
                            updateSymbolList();
                        }
                        isDragging = true;
                        dragOffset = { x: normX - clickedSymbol.x, y: normY - clickedSymbol.y };
                    }
                } else {
                    // Start selection box
                    if (!e.shiftKey) selectedSymbols.clear();
                    isSelectionDrag = true;
                    dragStart = { x: e.clientX - rect.left, y: e.clientY - rect.top };
                }
            } else if (currentTool === 'place') {
                // Place new symbol
                const type = canvas.dataset.placeType;
                if (type) {
                    const newSymbol = {
                        id: type.toUpperCase()[0] + (symbols.length + 1),
                        type: type,
                        automation_category: type,
                        x: normX,
                        y: normY,
                        room: '',
                        items: []
                    };
                    symbols.push(newSymbol);
                    render();
                    updateSymbolList();
                    updatePricing();
                }
            } else if (currentTool === 'rectangle') {
                // Start drawing rectangle
                isDrawingMarkup = true;
                currentMarkup = {
                    type: 'rectangle',
                    x: x,
                    y: y,
                    width: 0,
                    height: 0,
                    color: markupColor
                };
            } else if (currentTool === 'circle') {
                // Start drawing circle
                isDrawingMarkup = true;
                currentMarkup = {
                    type: 'circle',
                    centerX: x,
                    centerY: y,
                    radius: 0,
                    color: markupColor
                };
            } else if (currentTool === 'polygon') {
                // Add point to polygon
                polygonPoints.push({ x, y });
                if (!currentMarkup) {
                    currentMarkup = {
                        type: 'polygon',
                        points: [],
                        color: markupColor
                    };
                }
                render();
            } else if (currentTool === 'freehand') {
                // Start freehand drawing
                isDrawingMarkup = true;
                freehandPoints = [{ x, y }];
                currentMarkup = {
                    type: 'freehand',
                    points: [],
                    color: markupColor
                };
                render();
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / rect.width * canvas.width;
            const y = (e.clientY - rect.top) / rect.height * canvas.height;
            const normX = (e.clientX - rect.left) / canvas.width;
            const normY = (e.clientY - rect.top) / canvas.height;

            if (isDragging && selectedSymbols.size > 0) {
                selectedSymbols.forEach(id => {
                    const symbol = symbols.find(s => s.id === id);
                    if (symbol) {
                        symbol.x = Math.max(0, Math.min(1, normX - dragOffset.x));
                        symbol.y = Math.max(0, Math.min(1, normY - dragOffset.y));
                    }
                });
                render();
            } else if (isSelectionDrag) {
                const box = document.getElementById('selectionBox');
                box.style.display = 'block';
                const left = Math.min(dragStart.x, e.clientX - rect.left);
                const top = Math.min(dragStart.y, e.clientY - rect.top);
                const width = Math.abs(e.clientX - rect.left - dragStart.x);
                const height = Math.abs(e.clientY - rect.top - dragStart.y);
                box.style.left = left + 'px';
                box.style.top = top + 'px';
                box.style.width = width + 'px';
                box.style.height = height + 'px';
            } else if (isDrawingMarkup && currentMarkup) {
                if (currentMarkup.type === 'rectangle') {
                    currentMarkup.width = x - currentMarkup.x;
                    currentMarkup.height = y - currentMarkup.y;
                    render();
                } else if (currentMarkup.type === 'circle') {
                    const dx = x - currentMarkup.centerX;
                    const dy = y - currentMarkup.centerY;
                    currentMarkup.radius = Math.sqrt(dx * dx + dy * dy);
                    render();
                } else if (currentMarkup.type === 'freehand') {
                    freehandPoints.push({ x, y });
                    render();
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isSelectionDrag) {
                const rect = canvas.getBoundingClientRect();
                const x1 = Math.min(dragStart.x, e.clientX - rect.left) / canvas.width;
                const y1 = Math.min(dragStart.y, e.clientY - rect.top) / canvas.height;
                const x2 = Math.max(dragStart.x, e.clientX - rect.left) / canvas.width;
                const y2 = Math.max(dragStart.y, e.clientY - rect.top) / canvas.height;

                symbols.forEach(symbol => {
                    if (symbol.x >= x1 && symbol.x <= x2 && symbol.y >= y1 && symbol.y <= y2) {
                        selectedSymbols.add(symbol.id);
                    }
                });

                document.getElementById('selectionBox').style.display = 'none';
                render();
                updateSymbolList();
            }

            // Finalize markup drawing
            if (isDrawingMarkup && currentMarkup) {
                if (currentMarkup.type === 'rectangle' && (currentMarkup.width !== 0 || currentMarkup.height !== 0)) {
                    markups.push(currentMarkup);
                    console.log('‚úÖ Rectangle markup added');
                    saveState();
                } else if (currentMarkup.type === 'circle' && currentMarkup.radius > 0) {
                    markups.push(currentMarkup);
                    console.log('‚úÖ Circle markup added');
                    saveState();
                } else if (currentMarkup.type === 'freehand' && freehandPoints.length > 1) {
                    currentMarkup.points = freehandPoints;
                    markups.push(currentMarkup);
                    console.log('‚úÖ Freehand markup added');
                    saveState();
                }

                currentMarkup = null;
                freehandPoints = [];
                isDrawingMarkup = false;
                render();
            }

            isDragging = false;
            isSelectionDrag = false;
        });

        canvas.addEventListener('dblclick', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / canvas.width;
            const y = (e.clientY - rect.top) / canvas.height;

            // Double-click finishes polygon
            if (currentTool === 'polygon' && polygonPoints.length >= 3) {
                currentMarkup.points = polygonPoints;
                markups.push(currentMarkup);
                console.log('‚úÖ Polygon markup added');
                currentMarkup = null;
                polygonPoints = [];
                saveState();
                render();
                return;
            }

            symbols.forEach(symbol => {
                const dx = (symbol.x - x) * canvas.width;
                const dy = (symbol.y - y) * canvas.height;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 20) {
                    editSymbol(symbol.id);
                }
            });
        });

        // Context menu
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();

            const menu = document.getElementById('contextMenu');
            menu.style.display = 'block';
            menu.style.left = e.clientX + 'px';
            menu.style.top = e.clientY + 'px';
        });

        document.addEventListener('click', () => {
            document.getElementById('contextMenu').style.display = 'none';
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            const isInputFocused = document.activeElement.tagName === 'INPUT' ||
                                  document.activeElement.tagName === 'TEXTAREA';

            // Enter - Finish polygon
            if (e.key === 'Enter' && currentTool === 'polygon' && polygonPoints.length >= 3) {
                e.preventDefault();
                currentMarkup.points = polygonPoints;
                markups.push(currentMarkup);
                console.log('‚úÖ Polygon markup added (Enter)');
                currentMarkup = null;
                polygonPoints = [];
                saveState();
                render();
            }
            // Escape - Cancel polygon or clear selection
            else if (e.key === 'Escape') {
                if (currentTool === 'polygon' && polygonPoints.length > 0) {
                    // Cancel polygon drawing
                    currentMarkup = null;
                    polygonPoints = [];
                    console.log('‚ùå Polygon cancelled');
                    render();
                } else {
                    clearSelection();
                }
            }
            // Delete/Backspace - Delete selected
            else if ((e.key === 'Delete' || e.key === 'Backspace') && !isInputFocused) {
                e.preventDefault();
                deleteSelected();
            }
            // Ctrl+A - Select all
            else if (e.ctrlKey && e.key === 'a' && !isInputFocused) {
                e.preventDefault();
                selectAll();
            }
            // Ctrl+D - Duplicate
            else if (e.ctrlKey && e.key === 'd' && !isInputFocused) {
                e.preventDefault();
                duplicateSelected();
            }
        });

        function saveToMapping() {
            // Save current state to session
            const exportData = {
                session_id: sessionData.session_id,
                symbols: symbols,
                project_name: sessionData.project_name,
                tier: sessionData.tier
            };

            fetch('/api/takeoffs/export', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(exportData)
            })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    // Redirect to mapping tool with session
                    window.location.href = '/mapping?session=' + sessionData.session_id;
                } else {
                    alert('‚ùå Failed to save: ' + data.error);
                }
            })
            .catch(err => {
                alert('‚ùå Error: ' + err.message);
            });
        }

        async function exportResults() {
            if (confirm('Export final results and generate quote?')) {
                const exportData = {
                    session_id: sessionData.session_id,
                    symbols: symbols,
                    project_name: sessionData.project_name,
                    tier: sessionData.tier
                };

                try {
                    const response = await fetch('/api/takeoffs/export', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(exportData)
                    });

                    const data = await response.json();

                    if (data.success) {
                        alert('‚úÖ Export successful! Downloading files...');
                        // Download files
                        if (data.annotated_pdf) {
                            window.open(data.annotated_pdf, '_blank');
                        }
                        if (data.quote_pdf) {
                            window.open(data.quote_pdf, '_blank');
                        }
                    } else {
                        alert('‚ùå Export failed: ' + data.error);
                    }
                } catch (error) {
                    alert('‚ùå Export failed: ' + error.message);
                }
            }
        }

        function uploadCustomImage() {
            const file = document.getElementById('editSymbolImage').files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                if (editingSymbol) {
                    editingSymbol.custom_image_data = e.target.result;
                    render();
                    alert('‚úÖ Custom image uploaded to THIS symbol only!');
                }
            };
            reader.readAsDataURL(file);
        }

        function editSymbolFromContext() {
            if (selectedSymbols.size > 0) {
                editSymbol(Array.from(selectedSymbols)[0]);
            }
        }

        function duplicateFromContext() {
            duplicateSelected();
        }

        function deleteFromContext() {
            deleteSelected();
        }

        // ========================================
        // MULTI-PAGE PDF SUPPORT
        // ========================================

        async function loadPDFFile(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                pdfDocument = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                totalPages = pdfDocument.numPages;
                currentPage = 1;

                console.log(`üìÑ Loaded PDF with ${totalPages} pages`);

                // Show page controls if multi-page
                if (totalPages > 1) {
                    document.getElementById('pageControls').style.display = 'flex';
                    document.getElementById('totalPages').textContent = totalPages;
                    document.getElementById('pageInput').max = totalPages;
                }

                // Initialize page data for all pages
                for (let i = 1; i <= totalPages; i++) {
                    if (!pageData[i]) {
                        pageData[i] = {
                            symbols: [],
                            annotations: [],
                            markups: []
                        };
                    }
                }

                // Load first page
                await loadPDFPage(1);
                updatePageNavigation();
                saveState(); // Save initial state to undo stack

            } catch (error) {
                console.error('Error loading PDF:', error);
                alert('Failed to load PDF: ' + error.message);
            }
        }

        async function loadPDFPage(pageNum) {
            if (!pdfDocument) return;

            try {
                const page = await pdfDocument.getPage(pageNum);
                const viewport = page.getViewport({ scale: 2.5 });

                // Create temporary canvas to render PDF
                const tempCanvas = document.createElement('canvas');
                const tempContext = tempCanvas.getContext('2d');
                tempCanvas.width = viewport.width;
                tempCanvas.height = viewport.height;

                // Render PDF page to canvas
                await page.render({
                    canvasContext: tempContext,
                    viewport: viewport
                }).promise;

                // Convert canvas to image
                const img = new Image();
                img.onload = function() {
                    floorplanImage = img;
                    canvas.width = img.width;
                    canvas.height = img.height;
                    loadPageState(pageNum);
                    render();
                    updateSymbolList();
                    updatePricing();
                };
                img.src = tempCanvas.toDataURL();

            } catch (error) {
                console.error(`Error loading page ${pageNum}:`, error);
                alert(`Failed to load page ${pageNum}`);
            }
        }

        function changePage(newPage) {
            if (newPage < 1 || newPage > totalPages || newPage === currentPage) return;

            // Save current page state
            savePageState(currentPage);

            // Load new page
            currentPage = newPage;
            loadPDFPage(currentPage);
            updatePageNavigation();

            console.log(`üìÑ Switched to page ${currentPage}/${totalPages}`);
        }

        function jumpToPage(pageNum) {
            const num = parseInt(pageNum);
            if (isNaN(num) || num < 1 || num > totalPages) {
                alert(`Invalid page number. Enter a number between 1 and ${totalPages}`);
                document.getElementById('pageInput').value = currentPage;
                return;
            }
            changePage(num);
        }

        function updatePageNavigation() {
            document.getElementById('pageInput').value = currentPage;
            document.getElementById('prevPage').disabled = (currentPage <= 1);
            document.getElementById('nextPage').disabled = (currentPage >= totalPages);
        }

        function savePageState(pageNum) {
            pageData[pageNum] = {
                symbols: JSON.parse(JSON.stringify(symbols)),
                annotations: JSON.parse(JSON.stringify(annotations)),
                markups: JSON.parse(JSON.stringify(markups))
            };
        }

        function loadPageState(pageNum) {
            if (!pageData[pageNum]) {
                // Initialize empty page
                pageData[pageNum] = {
                    symbols: [],
                    annotations: [],
                    markups: []
                };
            }

            const state = pageData[pageNum];
            symbols = JSON.parse(JSON.stringify(state.symbols));
            annotations = JSON.parse(JSON.stringify(state.annotations));
            markups = JSON.parse(JSON.stringify(state.markups || []));
            selectedSymbols.clear();
        }

        // ========================================
        // UNDO/REDO SYSTEM
        // ========================================

        function saveState() {
            const state = {
                symbols: JSON.parse(JSON.stringify(symbols)),
                annotations: JSON.parse(JSON.stringify(annotations)),
                markups: JSON.parse(JSON.stringify(markups)),
                currentPage,
                pageData: JSON.parse(JSON.stringify(pageData))
            };

            undoStack.push(state);
            if (undoStack.length > MAX_UNDO_STACK) {
                undoStack.shift(); // Remove oldest
            }
            redoStack = []; // Clear redo stack on new action
        }

        function undoAction() {
            if (undoStack.length === 0) {
                console.log('Nothing to undo');
                return;
            }

            // Save current state to redo stack
            const currentState = {
                symbols: JSON.parse(JSON.stringify(symbols)),
                annotations: JSON.parse(JSON.stringify(annotations)),
                markups: JSON.parse(JSON.stringify(markups)),
                currentPage,
                pageData: JSON.parse(JSON.stringify(pageData))
            };
            redoStack.push(currentState);

            // Restore previous state
            const prevState = undoStack.pop();
            restoreState(prevState);

            console.log('‚Ü∂ Undo performed');
        }

        function redoAction() {
            if (redoStack.length === 0) {
                console.log('Nothing to redo');
                return;
            }

            // Save current state to undo stack
            const currentState = {
                symbols: JSON.parse(JSON.stringify(symbols)),
                annotations: JSON.parse(JSON.stringify(annotations)),
                markups: JSON.parse(JSON.stringify(markups)),
                currentPage,
                pageData: JSON.parse(JSON.stringify(pageData))
            };
            undoStack.push(currentState);

            // Restore next state
            const nextState = redoStack.pop();
            restoreState(nextState);

            console.log('‚Ü∑ Redo performed');
        }

        function restoreState(state) {
            symbols = JSON.parse(JSON.stringify(state.symbols));
            annotations = JSON.parse(JSON.stringify(state.annotations));
            markups = JSON.parse(JSON.stringify(state.markups || []));
            pageData = JSON.parse(JSON.stringify(state.pageData));

            if (state.currentPage && state.currentPage !== currentPage && pdfDocument) {
                changePage(state.currentPage);
            } else {
                render();
                updateSymbolList();
                updatePricing();
            }
        }

        // ========================================
        // SAVE/LOAD PROGRESS
        // ========================================

        function saveProgress() {
            // Save current page first
            if (currentPage && pageData[currentPage]) {
                savePageState(currentPage);
            }

            const progressData = {
                // Multi-page support
                pageData: pageData,
                currentPage: currentPage,
                totalPages: totalPages,
                hasPDF: !!pdfDocument,
                sessionData: sessionData,

                // Legacy support
                symbols: symbols,
                annotations: annotations,
                timestamp: Date.now(),
                version: '2.0'
            };

            try {
                const jsonString = JSON.stringify(progressData);
                if (jsonString.length > 5000000) {
                    alert('‚ö†Ô∏è Project too large for browser storage (>5MB). Exporting as file instead.');
                    downloadProjectFile(progressData);
                    return;
                }
                localStorage.setItem('takeoffs_progress', jsonString);
                alert(`‚úÖ Progress saved! (${totalPages} page${totalPages > 1 ? 's' : ''})`);
            } catch (e) {
                console.error('Save failed:', e);
                alert('‚ùå Save failed - exporting as file instead');
                downloadProjectFile(progressData);
            }
        }

        function loadProgress() {
            try {
                const savedData = localStorage.getItem('takeoffs_progress');
                if (savedData) {
                    const data = JSON.parse(savedData);
                    restoreProgress(data);
                    const pageInfo = data.totalPages > 1 ? ` (${data.totalPages} pages)` : '';
                    alert('‚úÖ Progress loaded from browser storage!' + pageInfo);
                    return;
                }
                alert('‚ö†Ô∏è No saved progress found');
            } catch (e) {
                console.error('Load failed:', e);
                alert('‚ùå Failed to load progress');
            }
        }

        function downloadProjectFile(data) {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `takeoffs-${sessionData.project_name || 'project'}-${new Date().toISOString().slice(0,10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
            alert('‚úÖ Project exported as JSON file');
        }

        function restoreProgress(data) {
            // Check if this is v2.0 (multi-page) or v1.0 (single page)
            if (data.version === '2.0' && data.pageData) {
                // NEW FORMAT: Multi-page support
                pageData = data.pageData || {};
                totalPages = data.totalPages || 1;
                currentPage = data.currentPage || 1;

                // Update page navigation
                if (totalPages > 1) {
                    document.getElementById('pageControls').style.display = 'flex';
                    document.getElementById('totalPages').textContent = totalPages;
                    document.getElementById('pageInput').max = totalPages;
                    updatePageNavigation();
                }

                // Load current page state
                loadPageState(currentPage);
            } else {
                // OLD FORMAT: Single page
                symbols = data.symbols || [];
                annotations = data.annotations || [];
            }

            render();
            updateSymbolList();
            updatePricing();
            console.log('‚úÖ Progress restored');
        }

        // ========================================
        // AUTO-SAVE FUNCTIONALITY
        // ========================================

        function startAutoSave() {
            // Auto-save every 30 seconds
            autoSaveInterval = setInterval(() => {
                autoSaveToLocalStorage();
            }, 30000);
            console.log('‚úÖ Auto-save enabled (every 30 seconds)');
        }

        function autoSaveToLocalStorage() {
            try {
                if (currentPage && pageData[currentPage]) {
                    savePageState(currentPage);
                }

                const autoSaveData = {
                    pageData: pageData,
                    currentPage: currentPage,
                    totalPages: totalPages,
                    sessionData: sessionData,
                    timestamp: Date.now(),
                    version: '2.0'
                };

                const jsonString = JSON.stringify(autoSaveData);
                if (jsonString.length < 5000000) {
                    localStorage.setItem('takeoffs_autosave', jsonString);
                    console.log('üíæ Auto-saved at ' + new Date().toLocaleTimeString());
                }
            } catch (e) {
                console.warn('Auto-save failed:', e.message);
            }
        }

        function loadAutoSave() {
            try {
                const savedData = localStorage.getItem('takeoffs_autosave');
                if (savedData) {
                    const data = JSON.parse(savedData);
                    const savedTime = new Date(data.timestamp).toLocaleString();
                    if (confirm(`Found auto-saved data from ${savedTime}. Restore it?`)) {
                        restoreProgress(data);
                        console.log('‚úÖ Auto-save restored');
                    }
                }
            } catch (e) {
                console.warn('Failed to load auto-save:', e.message);
            }
        }

        // ========================================
        // ENHANCED KEYBOARD SHORTCUTS
        // ========================================

        document.addEventListener('keydown', (e) => {
            const isInputFocused = document.activeElement.tagName === 'INPUT' ||
                                  document.activeElement.tagName === 'TEXTAREA';

            // Page Up/Down - Navigate pages
            if (e.key === 'PageUp' && totalPages > 1) {
                e.preventDefault();
                changePage(currentPage - 1);
            } else if (e.key === 'PageDown' && totalPages > 1) {
                e.preventDefault();
                changePage(currentPage + 1);
            }

            // Ctrl+Z - Undo
            if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undoAction();
            }

            // Ctrl+Y or Ctrl+Shift+Z - Redo
            if ((e.ctrlKey && e.key === 'y') || (e.ctrlKey && e.shiftKey && e.key === 'z')) {
                e.preventDefault();
                redoAction();
            }

            // Ctrl+S - Save
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                saveProgress();
            }

            // Ctrl+A - Select All
            if (e.ctrlKey && e.key === 'a' && !isInputFocused) {
                e.preventDefault();
                selectAll();
            }

            // Ctrl+D - Duplicate
            if (e.ctrlKey && e.key === 'd' && !isInputFocused) {
                e.preventDefault();
                duplicateSelected();
            }

            // Delete/Backspace - Delete selected
            if ((e.key === 'Delete' || e.key === 'Backspace') && !isInputFocused) {
                e.preventDefault();
                deleteSelected();
            }

            // Escape - Clear selection
            if (e.key === 'Escape') {
                clearSelection();
            }
        });

        // ========================================
        // ENHANCED CANVAS MOUSE HANDLERS
        // ========================================

        // Intercept mouseup to save state for undo/redo
        const originalMouseUp = canvas.onmouseup;
        canvas.addEventListener('mouseup', () => {
            if (isDragging || isSelectionDrag) {
                saveState(); // Enable undo/redo
            }
        });

        // ========================================
        // EXPORT TAKEOFFS REPORTS
        // ========================================

        function exportMarkupsToCSV() {
            // Gather all markups from all pages
            const allMarkups = [];

            // Save current page state first
            if (currentPage) {
                savePageState(currentPage);
            }

            // Collect markups from all pages
            for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                const page = pageData[pageNum];
                if (page && page.markups) {
                    page.markups.forEach(markup => {
                        allMarkups.push({
                            ...markup,
                            page: pageNum
                        });
                    });
                }
            }

            if (allMarkups.length === 0) {
                alert('‚ö†Ô∏è No markups found. Draw some markups first!');
                return;
            }

            // Calculate measurements for each markup
            const measurements = allMarkups.map((markup, idx) => {
                const tradeNames = {
                    '#e74c3c': 'Electrical',
                    '#3498db': 'Plumbing',
                    '#2ecc71': 'HVAC',
                    '#f39c12': 'Gas',
                    '#9b59b6': 'Data',
                    '#1abc9c': 'Security'
                };

                const trade = tradeNames[markup.color] || 'Other';
                let measurement = 0;
                let unit = '';
                let quantity = 1;

                if (markup.type === 'rectangle') {
                    measurement = Math.abs(markup.width * markup.height);
                    unit = 'sq px';
                    quantity = 1;
                } else if (markup.type === 'circle') {
                    measurement = Math.PI * markup.radius * markup.radius;
                    unit = 'sq px';
                    quantity = 1;
                } else if (markup.type === 'polygon' && markup.points) {
                    // Calculate polygon area using shoelace formula
                    let area = 0;
                    for (let i = 0; i < markup.points.length; i++) {
                        const j = (i + 1) % markup.points.length;
                        area += markup.points[i].x * markup.points[j].y;
                        area -= markup.points[j].x * markup.points[i].y;
                    }
                    measurement = Math.abs(area / 2);
                    unit = 'sq px';
                    quantity = 1;
                } else if (markup.type === 'freehand' && markup.points) {
                    // Calculate freehand length
                    let length = 0;
                    for (let i = 0; i < markup.points.length - 1; i++) {
                        const dx = markup.points[i + 1].x - markup.points[i].x;
                        const dy = markup.points[i + 1].y - markup.points[i].y;
                        length += Math.sqrt(dx * dx + dy * dy);
                    }
                    measurement = length;
                    unit = 'px';
                    quantity = 1;
                }

                return {
                    id: `Markup-${idx + 1}`,
                    type: markup.type.charAt(0).toUpperCase() + markup.type.slice(1),
                    trade: trade,
                    page: markup.page,
                    measurement: measurement.toFixed(2),
                    unit: unit,
                    quantity: quantity,
                    color: markup.color
                };
            });

            // Group by trade
            const byTrade = {};
            measurements.forEach(m => {
                if (!byTrade[m.trade]) {
                    byTrade[m.trade] = {
                        count: 0,
                        totalArea: 0,
                        totalLength: 0,
                        items: []
                    };
                }
                byTrade[m.trade].count++;
                byTrade[m.trade].items.push(m);

                if (m.unit === 'sq px') {
                    byTrade[m.trade].totalArea += parseFloat(m.measurement);
                } else if (m.unit === 'px') {
                    byTrade[m.trade].totalLength += parseFloat(m.measurement);
                }
            });

            // Generate CSV content
            let csv = 'Takeoffs Markup Report\n';
            csv += `Project: ${sessionData.project_name || 'Untitled'}\n`;
            csv += `Generated: ${new Date().toLocaleString()}\n`;
            csv += `Total Pages: ${totalPages}\n`;
            csv += `Total Markups: ${allMarkups.length}\n\n`;

            // Summary by trade
            csv += 'SUMMARY BY TRADE\n';
            csv += 'Trade,Count,Total Area (sq px),Total Length (px)\n';
            Object.keys(byTrade).forEach(trade => {
                const data = byTrade[trade];
                csv += `${trade},${data.count},${data.totalArea.toFixed(2)},${data.totalLength.toFixed(2)}\n`;
            });
            csv += '\n';

            // Detailed measurements
            csv += 'DETAILED MEASUREMENTS\n';
            csv += 'ID,Type,Trade,Page,Measurement,Unit,Quantity,Color\n';
            measurements.forEach(m => {
                csv += `${m.id},${m.type},${m.trade},${m.page},${m.measurement},${m.unit},${m.quantity},${m.color}\n`;
            });

            // Download CSV
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `takeoffs-markups-${sessionData.project_name || 'project'}-${new Date().toISOString().slice(0,10)}.csv`;
            a.click();
            URL.revokeObjectURL(url);

            console.log(`‚úÖ Exported ${measurements.length} markups to CSV`);
            alert(`‚úÖ Exported ${measurements.length} markups to CSV file!`);
        }

        function exportTakeoffsReport() {
            // Full report including symbols AND markups

            // Save current page state first
            if (currentPage) {
                savePageState(currentPage);
            }

            // Gather all data
            const allSymbols = [];
            const allMarkups = [];

            for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                const page = pageData[pageNum];
                if (page) {
                    if (page.symbols) {
                        page.symbols.forEach(symbol => {
                            allSymbols.push({ ...symbol, page: pageNum });
                        });
                    }
                    if (page.markups) {
                        page.markups.forEach(markup => {
                            allMarkups.push({ ...markup, page: pageNum });
                        });
                    }
                }
            }

            // Calculate pricing
            let subtotal = 0;
            allSymbols.forEach(symbol => {
                const automationType = symbol.automation_category || symbol.type;
                const tier = sessionData.tier || 'basic';

                if (automationData.automation_types[automationType]) {
                    const config = automationData.automation_types[automationType];
                    const unitCost = config.base_cost_per_unit[tier] || 0;
                    const laborHours = config.labor_hours[tier] || 0;
                    const laborCost = laborHours * automationData.labor_rate;
                    subtotal += unitCost + laborCost;
                }

                if (symbol.items && symbol.items.length > 0) {
                    symbol.items.forEach(item => {
                        const price = parseFloat(item.price) || 0;
                        const quantity = parseInt(item.quantity) || 1;
                        subtotal += price * quantity;
                    });
                }
            });

            const markup = subtotal * (automationData.markup_percentage / 100);
            const total = subtotal + markup;

            // Generate comprehensive CSV
            let csv = 'COMPREHENSIVE TAKEOFFS REPORT\n';
            csv += '=================================\n\n';
            csv += `Project: ${sessionData.project_name || 'Untitled'}\n`;
            csv += `Generated: ${new Date().toLocaleString()}\n`;
            csv += `Total Pages: ${totalPages}\n\n`;

            // Financial Summary
            csv += 'FINANCIAL SUMMARY\n';
            csv += `Subtotal,$${subtotal.toFixed(2)}\n`;
            csv += `Markup (${automationData.markup_percentage}%),$${markup.toFixed(2)}\n`;
            csv += `TOTAL,$${total.toFixed(2)}\n\n`;

            // Symbols Summary
            csv += 'SYMBOLS SUMMARY\n';
            csv += `Total Symbols: ${allSymbols.length}\n`;
            csv += 'ID,Type,Room,Page,Items Count\n';
            allSymbols.forEach(symbol => {
                csv += `${symbol.id},${symbol.automation_category || symbol.type},${symbol.room || 'Unassigned'},${symbol.page},${symbol.items ? symbol.items.length : 0}\n`;
            });
            csv += '\n';

            // Markups Summary (use the same logic from exportMarkupsToCSV)
            if (allMarkups.length > 0) {
                csv += 'MARKUPS SUMMARY\n';
                csv += `Total Markups: ${allMarkups.length}\n`;
                csv += 'ID,Type,Trade,Page,Measurement,Unit\n';

                allMarkups.forEach((markup, idx) => {
                    const tradeNames = {
                        '#e74c3c': 'Electrical',
                        '#3498db': 'Plumbing',
                        '#2ecc71': 'HVAC',
                        '#f39c12': 'Gas',
                        '#9b59b6': 'Data',
                        '#1abc9c': 'Security'
                    };
                    const trade = tradeNames[markup.color] || 'Other';
                    let measurement = 0;
                    let unit = '';

                    if (markup.type === 'rectangle') {
                        measurement = Math.abs(markup.width * markup.height);
                        unit = 'sq px';
                    } else if (markup.type === 'circle') {
                        measurement = Math.PI * markup.radius * markup.radius;
                        unit = 'sq px';
                    } else if (markup.type === 'polygon' && markup.points) {
                        let area = 0;
                        for (let i = 0; i < markup.points.length; i++) {
                            const j = (i + 1) % markup.points.length;
                            area += markup.points[i].x * markup.points[j].y;
                            area -= markup.points[j].x * markup.points[i].y;
                        }
                        measurement = Math.abs(area / 2);
                        unit = 'sq px';
                    } else if (markup.type === 'freehand' && markup.points) {
                        let length = 0;
                        for (let i = 0; i < markup.points.length - 1; i++) {
                            const dx = markup.points[i + 1].x - markup.points[i].x;
                            const dy = markup.points[i + 1].y - markup.points[i].y;
                            length += Math.sqrt(dx * dx + dy * dy);
                        }
                        measurement = length;
                        unit = 'px';
                    }

                    csv += `Markup-${idx + 1},${markup.type},${trade},${markup.page},${measurement.toFixed(2)},${unit}\n`;
                });
            }

            // Download CSV
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `takeoffs-full-report-${sessionData.project_name || 'project'}-${new Date().toISOString().slice(0,10)}.csv`;
            a.click();
            URL.revokeObjectURL(url);

            console.log(`‚úÖ Exported full report: ${allSymbols.length} symbols, ${allMarkups.length} markups`);
            alert(`‚úÖ Exported full takeoffs report!\n\nSymbols: ${allSymbols.length}\nMarkups: ${allMarkups.length}\nTotal: $${total.toFixed(2)}`);
        }

        // ========================================
        // INITIALIZATION
        // ========================================

        // Check for auto-saved data on page load
        setTimeout(() => {
            loadAutoSave();
        }, 1000);

        // Start auto-save
        startAutoSave();

        // Initialize default color swatch
        document.querySelector('.color-swatch[data-color="#e74c3c"]').classList.add('selected');

        // Log initialization
        console.log(`
        ===================================
        üé® TAKEOFFS APP v2.0
        ===================================
        ‚úÖ Multi-page PDF support
        ‚úÖ Undo/Redo (Ctrl+Z / Ctrl+Y)
        ‚úÖ Auto-save (every 30s)
        ‚úÖ Advanced Markup Tools:
           ‚Ä¢ Rectangle (drag to draw)
           ‚Ä¢ Circle (drag to draw)
           ‚Ä¢ Polygon (click points, Enter/double-click to finish)
           ‚Ä¢ Freehand (drag to draw)
           ‚Ä¢ Color-coded by trade (Electrical, Plumbing, HVAC, etc.)
        ‚úÖ Keyboard shortcuts:
           ‚Ä¢ Page Up/Down = Navigate pages
           ‚Ä¢ Ctrl+S = Save
           ‚Ä¢ Ctrl+Z/Y = Undo/Redo
           ‚Ä¢ Ctrl+A = Select All
           ‚Ä¢ Ctrl+D = Duplicate
           ‚Ä¢ Delete = Delete selected
           ‚Ä¢ Enter = Finish polygon
           ‚Ä¢ Esc = Cancel polygon / Clear selection
        ‚úÖ Professional takeoff tools
        ===================================
        `);
    </script>
</body>
</html>
