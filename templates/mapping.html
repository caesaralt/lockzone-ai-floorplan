<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electrical Mapping - {{ project_name | default('New Project') }}</title>
    <!-- PDF.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
    <script>
        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js';
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0e14;
            overflow: hidden;
            color: #ecf0f1;
        }

        .top-toolbar {
            background: linear-gradient(135deg, #1a252f 0%, #0f1419 100%);
            padding: 10px 20px;
            border-bottom: 2px solid #3498db;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 4px 12px rgba(0,0,0,0.6);
        }

        .toolbar-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .project-title {
            font-size: 1.2em;
            font-weight: 700;
            color: #3498db;
        }

        .toolbar-btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            border: 2px solid transparent;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.3s;
            white-space: nowrap;
        }

        .toolbar-btn input[type="file"] {
            display: none;
        }

        .toolbar-btn:hover {
            background: linear-gradient(135deg, #2c3e50 0%, #1a252f 100%);
            border-color: #3498db;
            transform: translateY(-1px);
        }

        .toolbar-btn.success {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
        }

        .toolbar-btn.ai {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #16213e;
            padding: 5px 12px;
            border-radius: 6px;
            border: 2px solid #2c3e50;
        }

        .zoom-btn {
            background: #2c3e50;
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .zoom-btn:hover {
            background: #34495e;
            transform: scale(1.1);
        }

        .zoom-level {
            color: #3498db;
            font-weight: 600;
            min-width: 50px;
            text-align: center;
        }

        .app-container {
            display: flex;
            height: calc(100vh - 52px);
        }

        .left-panel, .right-panel {
            width: 280px;
            background: #16213e;
            padding: 15px;
            overflow-y: auto;
            border-right: 2px solid #2c3e50;
        }

        .right-panel {
            border-right: none;
            border-left: 2px solid #2c3e50;
        }

        .panel-section {
            margin-bottom: 20px;
        }

        .panel-section h3 {
            color: #3498db;
            margin-bottom: 10px;
            font-size: 1em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }

        .layer-item, .component-btn {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            margin-bottom: 6px;
            background: #2c3e50;
            border: 2px solid transparent;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9em;
        }

        .component-btn:hover, .layer-item:hover {
            background: #34495e;
            border-color: #3498db;
            transform: translateX(4px);
        }

        .component-btn.active {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            border-color: #3498db;
        }

        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #0f1419;
            position: relative;
            overflow: hidden;
        }

        .canvas-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #mappingCanvas {
            cursor: crosshair;
            transform-origin: 0 0;
            transition: transform 0.1s ease-out;
        }

        .canvas-wrapper.panning #mappingCanvas {
            cursor: grab;
        }

        .canvas-wrapper.panning:active #mappingCanvas {
            cursor: grabbing;
        }

        .properties-panel {
            background: #2c3e50;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }

        .properties-panel h3 {
            color: #3498db;
            margin-bottom: 10px;
            font-size: 0.95em;
        }

        .prop-group {
            margin-bottom: 12px;
        }

        .prop-group label {
            display: block;
            color: #95a5a6;
            font-size: 0.8em;
            margin-bottom: 4px;
            font-weight: 600;
        }

        .prop-group input, .prop-group select {
            width: 100%;
            padding: 8px;
            background: #34495e;
            border: 2px solid #2c3e50;
            border-radius: 4px;
            color: white;
            font-size: 0.9em;
        }

        .prop-group input:focus, .prop-group select:focus {
            outline: none;
            border-color: #3498db;
        }

        .circuit-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .circuit-item {
            background: #34495e;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 6px;
            border-left: 4px solid #e74c3c;
        }

        .circuit-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .circuit-name {
            font-weight: 600;
            color: #3498db;
        }

        .circuit-info {
            font-size: 0.8em;
            color: #95a5a6;
        }

        .legend {
            margin-top: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.85em;
        }

        .legend-color {
            width: 30px;
            height: 3px;
            margin-right: 8px;
        }

        .context-menu {
            display: none;
            position: absolute;
            background: #2c3e50;
            border: 2px solid #3498db;
            border-radius: 6px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.6);
            z-index: 1000;
            min-width: 180px;
        }

        .context-menu-item {
            padding: 10px 15px;
            cursor: pointer;
            color: white;
            transition: all 0.2s;
            font-size: 0.9em;
        }

        .context-menu-item:hover {
            background: #3498db;
        }

        .ai-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(22, 33, 62, 0.95);
            padding: 30px;
            border-radius: 12px;
            border: 2px solid #9b59b6;
            text-align: center;
            z-index: 100;
            display: none;
        }

        .ai-loading.active {
            display: block;
        }

        .spinner {
            border: 4px solid rgba(155, 89, 182, 0.3);
            border-top: 4px solid #9b59b6;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="top-toolbar">
        <div class="toolbar-left">
            <div class="project-title">‚ö° {{ project_name | default('Electrical Mapping') }}</div>
            <label class="toolbar-btn">
                üìÅ Upload Floor Plan
                <input type="file" id="floorplanUpload" accept=".pdf,image/*">
            </label>
        </div>
        <div class="zoom-controls">
            <button class="zoom-btn" onclick="zoomIn()">+</button>
            <span class="zoom-level" id="zoomLevel">100%</span>
            <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
            <button class="zoom-btn" onclick="resetView()">‚ü≤</button>
        </div>
        <div>
            <button class="toolbar-btn" onclick="window.location.href='/canvas'">‚Üê Canvas</button>
            <button class="toolbar-btn" onclick="importFromTakeoffs()">üì• Import from Takeoffs</button>
            <button class="toolbar-btn ai" onclick="runAIMapping()">ü§ñ AI Mapping</button>
            <button class="toolbar-btn success" onclick="exportMapping()">üíæ Export</button>
        </div>
    </div>

    <div class="app-container">
        <!-- LEFT PANEL: Layers & Components -->
        <div class="left-panel">
            <div class="panel-section">
                <h3>üìÅ Layers</h3>
                <div class="layer-item active">
                    <span><input type="checkbox" id="layerFloorplan" class="layer-checkbox" checked> Floor Plan</span>
                </div>
                <div class="layer-item active">
                    <span><input type="checkbox" id="layerComponents" class="layer-checkbox" checked> Components</span>
                </div>
                <div class="layer-item active">
                    <span><input type="checkbox" id="layerWiring" class="layer-checkbox" checked> Wiring</span>
                </div>
                <div class="layer-item active">
                    <span><input type="checkbox" id="layerCircuits" class="layer-checkbox" checked> Circuits</span>
                </div>
                <div class="layer-item active">
                    <span><input type="checkbox" id="layerAnnotations" class="layer-checkbox" checked> Annotations</span>
                </div>
            </div>

            <div class="panel-section">
                <h3>üîß Components</h3>
                <button class="component-btn" onclick="selectComponent('light')">
                    üí° Light Fixture
                </button>
                <button class="component-btn" onclick="selectComponent('switch')">
                    üîò Switch
                </button>
                <button class="component-btn" onclick="selectComponent('outlet')">
                    ‚ö° Outlet
                </button>
                <button class="component-btn" onclick="selectComponent('panel')">
                    ‚öôÔ∏è Electrical Panel
                </button>
                <button class="component-btn" onclick="selectComponent('junction')">
                    üì¶ Junction Box
                </button>
                <button class="component-btn" onclick="selectComponent('sensor')">
                    üì° Sensor/Detector
                </button>
                <button class="component-btn" onclick="selectComponent('dimmer')">
                    üéöÔ∏è Dimmer
                </button>
                <button class="component-btn" onclick="selectComponent('fan')">
                    üåÄ Ceiling Fan
                </button>
            </div>

            <div class="panel-section">
                <h3>üõ†Ô∏è Tools</h3>
                <button class="component-btn active" id="selectTool" onclick="setTool('select')">
                    üñ±Ô∏è Select & Pan
                </button>
                <button class="component-btn" id="wireTool" onclick="setTool('wire')">
                    üîå Draw Wire
                </button>
                <button class="component-btn" id="measureTool" onclick="setTool('measure')">
                    üìè Measure
                </button>
                <button class="component-btn" id="annotateTool" onclick="setTool('annotate')">
                    üìù Annotate
                </button>
            </div>
        </div>

        <!-- CENTER: Canvas -->
        <div class="canvas-area">
            <div class="canvas-wrapper" id="canvasWrapper">
                <canvas id="mappingCanvas"></canvas>
            </div>
            <div class="ai-loading" id="aiLoading">
                <div class="spinner"></div>
                <p style="color: #9b59b6; font-weight: 600; font-size: 1.1em;">ü§ñ AI is analyzing your floor plan...</p>
                <p style="color: #95a5a6; font-size: 0.9em; margin-top: 8px;">This may take a few moments</p>
            </div>
        </div>

        <!-- RIGHT PANEL: Properties & Circuits -->
        <div class="right-panel">
            <div class="properties-panel">
                <h3>‚öôÔ∏è Properties</h3>
                <div id="propertiesContent">
                    <p style="color: #95a5a6; font-size: 0.85em;">Select a component to edit properties</p>
                </div>
            </div>

            <div class="properties-panel">
                <h3>üîå Circuits</h3>
                <button class="toolbar-btn" style="width: 100%; margin-bottom: 10px;" onclick="createCircuit()">‚ûï New Circuit</button>
                <div class="circuit-list" id="circuitList">
                    <p style="color: #95a5a6; font-size: 0.85em;">No circuits created yet</p>
                </div>
            </div>

            <div class="properties-panel">
                <h3>üìä Wire Legend</h3>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e74c3c;"></div>
                        <span>120V Power</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #9b59b6;"></div>
                        <span>240V Power</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3498db;"></div>
                        <span>Control/Signal</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #2ecc71;"></div>
                        <span>Low Voltage</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" onclick="editComponent()">‚úèÔ∏è Edit Properties</div>
        <div class="context-menu-item" onclick="duplicateComponent()">üìã Duplicate</div>
        <div class="context-menu-item" onclick="assignCircuitToComp()">üîå Assign to Circuit</div>
        <div class="context-menu-item" onclick="deleteComponent()">üóëÔ∏è Delete</div>
    </div>

    <script>
        const canvas = document.getElementById('mappingCanvas');
        const ctx = canvas.getContext('2d');
        const canvasWrapper = document.getElementById('canvasWrapper');

        // Initialize canvas size
        canvas.width = 1400;
        canvas.height = 900;

        // Pan & Zoom state
        let panX = 0, panY = 0;
        let scale = 1;
        let isPanning = false;
        let lastPanX = 0, lastPanY = 0;

        // State
        let floorplanImage = null;
        let components = [];
        let wires = [];
        let circuits = [];
        let selectedComponent = null;
        let currentTool = 'select';
        let pendingComponentType = null;
        let wireStart = null;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };

        // Layer visibility
        let layers = {
            floorplan: true,
            components: true,
            wiring: true,
            circuits: true,
            annotations: true
        };

        // Component types configuration
        const componentConfig = {
            light: { symbol: 'üí°', color: '#FFD700', size: 20, name: 'Light Fixture' },
            switch: { symbol: 'üîò', color: '#4169E1', size: 16, name: 'Switch' },
            outlet: { symbol: '‚ö°', color: '#32CD32', size: 16, name: 'Outlet' },
            panel: { symbol: '‚öôÔ∏è', color: '#FF4500', size: 28, name: 'Electrical Panel' },
            junction: { symbol: 'üì¶', color: '#FFA500', size: 18, name: 'Junction Box' },
            sensor: { symbol: 'üì°', color: '#9370DB', size: 18, name: 'Sensor' },
            dimmer: { symbol: 'üéöÔ∏è', color: '#00CED1', size: 18, name: 'Dimmer' },
            fan: { symbol: 'üåÄ', color: '#4682B4', size: 22, name: 'Ceiling Fan' }
        };

        // Pan & Zoom Functions
        function zoomIn() {
            scale = Math.min(scale * 1.2, 5);
            updateTransform();
        }

        function zoomOut() {
            scale = Math.max(scale / 1.2, 0.2);
            updateTransform();
        }

        function resetView() {
            scale = 1;
            panX = 0;
            panY = 0;
            updateTransform();
        }

        function updateTransform() {
            canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
            document.getElementById('zoomLevel').textContent = Math.round(scale * 100) + '%';
        }

        // Layer toggle
        document.querySelectorAll('.layer-checkbox').forEach((checkbox, index) => {
            checkbox.addEventListener('change', (e) => {
                const layerNames = ['floorplan', 'components', 'wiring', 'circuits', 'annotations'];
                layers[layerNames[index]] = e.target.checked;
                render();
            });
        });

        // Render function
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Background
            ctx.fillStyle = '#f5f5f5';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw floor plan if loaded and layer is visible
            if (floorplanImage && layers.floorplan) {
                ctx.globalAlpha = 0.7;
                ctx.drawImage(floorplanImage, 0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1;
            }

            // Draw grid for precision
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;
            const gridSize = 50;
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw wires (behind components)
            if (layers.wiring) {
                wires.forEach(wire => {
                    ctx.strokeStyle = wire.type === 'power120' ? '#e74c3c' :
                                     wire.type === 'power240' ? '#9b59b6' :
                                     wire.type === 'control' ? '#3498db' : '#2ecc71';
                    ctx.lineWidth = 4;
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.moveTo(wire.from.x, wire.from.y);
                    ctx.lineTo(wire.to.x, wire.to.y);
                    ctx.stroke();

                    // Draw circuit label
                    if (wire.circuit && layers.circuits) {
                        const midX = (wire.from.x + wire.to.x) / 2;
                        const midY = (wire.from.y + wire.to.y) / 2;
                        ctx.font = 'bold 12px Arial';
                        ctx.fillStyle = '#ffffff';
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 3;
                        ctx.strokeText(`C${wire.circuit}`, midX, midY);
                        ctx.fillText(`C${wire.circuit}`, midX, midY);
                    }
                });
            }

            // Draw components
            if (layers.components) {
                components.forEach(comp => {
                    const config = componentConfig[comp.type] || componentConfig.light;
                    const isSelected = selectedComponent === comp;

                    // Draw background circle
                    ctx.beginPath();
                    ctx.arc(comp.x, comp.y, isSelected ? config.size + 6 : config.size, 0, 2 * Math.PI);
                    ctx.fillStyle = isSelected ? 'rgba(52, 152, 219, 0.3)' : 'rgba(255, 255, 255, 0.9)';
                    ctx.fill();
                    ctx.strokeStyle = config.color;
                    ctx.lineWidth = isSelected ? 4 : 3;
                    ctx.stroke();

                    // Draw symbol
                    ctx.font = `${config.size + 4}px Arial`;
                    const symbolWidth = ctx.measureText(config.symbol).width;
                    ctx.fillText(config.symbol, comp.x - symbolWidth / 2, comp.y + (config.size / 2));

                    // Draw label
                    if (comp.label) {
                        ctx.font = 'bold 11px Arial';
                        ctx.fillStyle = '#2c3e50';
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 3;
                        ctx.strokeText(comp.label, comp.x + config.size + 5, comp.y - 10);
                        ctx.fillText(comp.label, comp.x + config.size + 5, comp.y - 10);
                    }

                    // Draw circuit assignment
                    if (comp.circuit && layers.circuits) {
                        ctx.font = 'bold 10px Arial';
                        ctx.fillStyle = '#f39c12';
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        ctx.strokeText(`C${comp.circuit}`, comp.x - 10, comp.y + config.size + 15);
                        ctx.fillText(`C${comp.circuit}`, comp.x - 10, comp.y + config.size + 15);
                    }
                });
            }

            // Draw wireStart indicator when drawing wire
            if (wireStart && currentTool === 'wire') {
                ctx.fillStyle = 'rgba(52, 152, 219, 0.5)';
                ctx.beginPath();
                ctx.arc(wireStart.x, wireStart.y, 8, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        // Tool selection
        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.component-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tool + 'Tool')?.classList.add('active');

            if (tool === 'wire') {
                wireStart = null;
            }

            canvas.style.cursor = tool === 'select' ? 'default' : 'crosshair';
        }

        function selectComponent(type) {
            pendingComponentType = type;
            currentTool = 'place';
            canvas.style.cursor = 'crosshair';
        }

        // Mouse events
        canvasWrapper.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            if (currentTool === 'select') {
                // Check if clicking on component
                let clickedComp = null;
                components.forEach(comp => {
                    const config = componentConfig[comp.type] || componentConfig.light;
                    const dx = comp.x - x;
                    const dy = comp.y - y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < config.size + 10) {
                        clickedComp = comp;
                    }
                });

                if (clickedComp) {
                    selectedComponent = clickedComp;
                    isDragging = true;
                    dragOffset = { x: x - clickedComp.x, y: y - clickedComp.y };
                    showProperties(clickedComp);
                    render();
                } else {
                    // Start panning
                    isPanning = true;
                    lastPanX = e.clientX;
                    lastPanY = e.clientY;
                    canvasWrapper.classList.add('panning');
                }
            } else if (currentTool === 'place' && pendingComponentType) {
                // Place component
                const newComp = {
                    id: components.length + 1,
                    type: pendingComponentType,
                    x: x,
                    y: y,
                    label: `${componentConfig[pendingComponentType].name} ${components.length + 1}`,
                    circuit: null
                };
                components.push(newComp);
                render();
            } else if (currentTool === 'wire') {
                // Wire drawing
                if (!wireStart) {
                    // Find nearest component
                    let nearest = null;
                    let minDist = 30;
                    components.forEach(comp => {
                        const dx = comp.x - x;
                        const dy = comp.y - y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < minDist) {
                            nearest = comp;
                            minDist = dist;
                        }
                    });

                    if (nearest) {
                        wireStart = { x: nearest.x, y: nearest.y, comp: nearest };
                        render();
                    }
                } else {
                    // Complete wire
                    let nearest = null;
                    let minDist = 30;
                    components.forEach(comp => {
                        if (comp !== wireStart.comp) {
                            const dx = comp.x - x;
                            const dy = comp.y - y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < minDist) {
                                nearest = comp;
                                minDist = dist;
                            }
                        }
                    });

                    if (nearest) {
                        const wireType = prompt('Wire type:\n1 = 120V Power\n2 = 240V Power\n3 = Control\n4 = Low Voltage', '1');
                        const typeMap = { '1': 'power120', '2': 'power240', '3': 'control', '4': 'lowvoltage' };

                        wires.push({
                            from: { x: wireStart.x, y: wireStart.y },
                            to: { x: nearest.x, y: nearest.y },
                            type: typeMap[wireType] || 'power120',
                            circuit: null
                        });
                        wireStart = null;
                        render();
                    }
                }
            }
        });

        canvasWrapper.addEventListener('mousemove', (e) => {
            if (isPanning) {
                const dx = e.clientX - lastPanX;
                const dy = e.clientY - lastPanY;
                panX += dx;
                panY += dy;
                lastPanX = e.clientX;
                lastPanY = e.clientY;
                updateTransform();
            } else if (isDragging && selectedComponent) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;

                selectedComponent.x = x - dragOffset.x;
                selectedComponent.y = y - dragOffset.y;
                render();
            }
        });

        canvasWrapper.addEventListener('mouseup', () => {
            isPanning = false;
            isDragging = false;
            canvasWrapper.classList.remove('panning');
        });

        // Zoom with mouse wheel
        canvasWrapper.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.deltaY < 0) {
                zoomIn();
            } else {
                zoomOut();
            }
        });

        // Right-click context menu
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (selectedComponent) {
                const menu = document.getElementById('contextMenu');
                menu.style.display = 'block';
                menu.style.left = e.pageX + 'px';
                menu.style.top = e.pageY + 'px';
            }
        });

        document.addEventListener('click', () => {
            document.getElementById('contextMenu').style.display = 'none';
        });

        // Properties panel
        function showProperties(comp) {
            const config = componentConfig[comp.type];
            document.getElementById('propertiesContent').innerHTML = `
                <div class="prop-group">
                    <label>Type</label>
                    <select id="propType" onchange="updateComponentProp('type', this.value)">
                        ${Object.keys(componentConfig).map(key =>
                            `<option value="${key}" ${comp.type === key ? 'selected' : ''}>${componentConfig[key].name}</option>`
                        ).join('')}
                    </select>
                </div>
                <div class="prop-group">
                    <label>Label</label>
                    <input type="text" id="propLabel" value="${comp.label || ''}" onchange="updateComponentProp('label', this.value)">
                </div>
                <div class="prop-group">
                    <label>Circuit</label>
                    <select id="propCircuit" onchange="updateComponentProp('circuit', this.value)">
                        <option value="">Unassigned</option>
                        ${circuits.map(c => `<option value="${c.number}" ${comp.circuit == c.number ? 'selected' : ''}>Circuit ${c.number}</option>`).join('')}
                    </select>
                </div>
                <div class="prop-group">
                    <label>Position</label>
                    <input type="text" value="X: ${Math.round(comp.x)}, Y: ${Math.round(comp.y)}" readonly>
                </div>
            `;
        }

        function updateComponentProp(prop, value) {
            if (selectedComponent) {
                selectedComponent[prop] = value === '' ? null : value;
                render();
                showProperties(selectedComponent);
            }
        }

        // Context menu functions
        function editComponent() {
            if (selectedComponent) {
                showProperties(selectedComponent);
            }
        }

        function duplicateComponent() {
            if (selectedComponent) {
                const newComp = {
                    ...selectedComponent,
                    id: components.length + 1,
                    x: selectedComponent.x + 30,
                    y: selectedComponent.y + 30,
                    label: selectedComponent.label + ' (copy)'
                };
                components.push(newComp);
                selectedComponent = newComp;
                render();
            }
        }

        function assignCircuitToComp() {
            if (selectedComponent && circuits.length > 0) {
                const circuitNum = prompt(`Assign to circuit (1-${circuits.length}):`);
                if (circuitNum && circuits.find(c => c.number == circuitNum)) {
                    selectedComponent.circuit = parseInt(circuitNum);
                    render();
                    showProperties(selectedComponent);
                    updateCircuitList();
                }
            } else if (circuits.length === 0) {
                alert('Create a circuit first!');
            }
        }

        function deleteComponent() {
            if (selectedComponent && confirm('Delete this component?')) {
                components = components.filter(c => c !== selectedComponent);
                selectedComponent = null;
                document.getElementById('propertiesContent').innerHTML = '<p style="color: #95a5a6; font-size: 0.85em;">Select a component to edit properties</p>';
                render();
            }
        }

        // Circuit management
        function createCircuit() {
            const name = prompt('Circuit name:', `Circuit ${circuits.length + 1}`);
            if (name) {
                const amperage = prompt('Amperage (A):', '15');
                const voltage = prompt('Voltage (V):', '120');

                circuits.push({
                    number: circuits.length + 1,
                    name: name,
                    amperage: parseInt(amperage) || 15,
                    voltage: parseInt(voltage) || 120
                });
                updateCircuitList();
            }
        }

        function updateCircuitList() {
            const list = document.getElementById('circuitList');
            list.innerHTML = '';

            if (circuits.length === 0) {
                list.innerHTML = '<p style="color: #95a5a6; font-size: 0.85em;">No circuits created yet</p>';
                return;
            }

            const circuitMap = {};
            components.forEach(comp => {
                if (comp.circuit) {
                    if (!circuitMap[comp.circuit]) circuitMap[comp.circuit] = [];
                    circuitMap[comp.circuit].push(comp);
                }
            });

            circuits.forEach(circuit => {
                const div = document.createElement('div');
                div.className = 'circuit-item';
                div.innerHTML = `
                    <div class="circuit-header">
                        <span class="circuit-name">${circuit.name}</span>
                    </div>
                    <div class="circuit-info">${circuit.voltage}V, ${circuit.amperage}A</div>
                    <div class="circuit-info">${circuitMap[circuit.number]?.length || 0} component(s)</div>
                `;
                list.appendChild(div);
            });
        }

        // Floor plan upload with PDF support
        document.getElementById('floorplanUpload').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            if (file.type === 'application/pdf') {
                // Handle PDF using PDF.js
                const fileReader = new FileReader();
                fileReader.onload = async function(event) {
                    try {
                        const typedarray = new Uint8Array(event.target.result);
                        const pdf = await pdfjsLib.getDocument(typedarray).promise;

                        // Get first page
                        const page = await pdf.getPage(1);
                        const viewport = page.getViewport({ scale: 2.0 });

                        // Create temporary canvas to render PDF
                        const tempCanvas = document.createElement('canvas');
                        const tempContext = tempCanvas.getContext('2d');
                        tempCanvas.width = viewport.width;
                        tempCanvas.height = viewport.height;

                        // Render PDF page to canvas
                        await page.render({
                            canvasContext: tempContext,
                            viewport: viewport
                        }).promise;

                        // Convert canvas to image
                        const img = new Image();
                        img.onload = function() {
                            floorplanImage = img;
                            render();
                            alert('‚úÖ PDF loaded successfully!');
                        };
                        img.src = tempCanvas.toDataURL();
                    } catch (error) {
                        console.error('PDF loading error:', error);
                        alert('Failed to load PDF: ' + error.message);
                    }
                };
                fileReader.readAsArrayBuffer(file);
            } else {
                // Handle image files
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        floorplanImage = img;
                        render();
                        alert('‚úÖ Image loaded successfully!');
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // Import from takeoffs
        function importFromTakeoffs() {
            const sessionId = new URLSearchParams(window.location.search).get('session');
            if (!sessionId) {
                alert('No session found. Please export from Canvas/Takeoffs first.');
                return;
            }

            fetch('/api/session/' + sessionId)
                .then(r => r.json())
                .then(data => {
                    if (data.symbols) {
                        components = data.symbols.map((sym, i) => ({
                            id: i + 1,
                            type: sym.automation_category || sym.type || 'light',
                            x: sym.x * canvas.width,
                            y: sym.y * canvas.height,
                            label: sym.label || sym.id,
                            circuit: null
                        }));

                        // Load floorplan if available
                        if (data.floorplan_image) {
                            const img = new Image();
                            img.onload = function() {
                                floorplanImage = img;
                                render();
                            };
                            img.src = '/static/uploads/' + data.floorplan_image;
                        }

                        render();
                        alert(`‚úÖ Imported ${components.length} components from takeoffs!`);
                    }
                })
                .catch(err => {
                    console.error('Import failed:', err);
                    alert('Failed to import from takeoffs');
                });
        }

        // AI Mapping
        async function runAIMapping() {
            if (!floorplanImage) {
                alert('Please upload a floor plan first!');
                return;
            }

            if (!confirm('Run AI analysis to automatically place electrical components? This will replace any existing components.')) {
                return;
            }

            const aiLoading = document.getElementById('aiLoading');
            aiLoading.classList.add('active');

            try {
                // Convert canvas to blob
                const imageData = canvas.toDataURL('image/jpeg', 0.9);

                const response = await fetch('/api/ai/mapping', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        floor_plan_image: imageData,
                        canvas_width: canvas.width,
                        canvas_height: canvas.height
                    })
                });

                const data = await response.json();

                if (data.success && data.components) {
                    components = data.components;
                    render();
                    alert(`‚úÖ AI placed ${components.length} electrical components!`);
                } else {
                    alert('AI mapping failed: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('AI mapping error:', error);
                alert('Failed to run AI mapping: ' + error.message);
            } finally {
                aiLoading.classList.remove('active');
            }
        }

        // Export mapping
        async function exportMapping() {
            if (components.length === 0) {
                alert('Add some components first!');
                return;
            }

            try {
                const exportData = {
                    components: components,
                    wires: wires,
                    circuits: circuits,
                    canvas_width: canvas.width,
                    canvas_height: canvas.height
                };

                const response = await fetch('/api/mapping/export', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(exportData)
                });

                const data = await response.json();

                if (data.success) {
                    alert('‚úÖ Mapping exported successfully!');
                    if (data.file) {
                        window.open(data.file, '_blank');
                    }
                } else {
                    alert('Export failed: ' + data.error);
                }
            } catch (error) {
                console.error('Export error:', error);
                alert('Failed to export: ' + error.message);
            }
        }

        // Keyboard Shortcuts
        let clipboard = null;  // For copy/paste
        let undoStack = [];
        let redoStack = [];

        function saveState() {
            undoStack.push({
                components: JSON.parse(JSON.stringify(components)),
                wires: JSON.parse(JSON.stringify(wires))
            });
            // Limit undo stack size
            if (undoStack.length > 50) undoStack.shift();
            redoStack = [];  // Clear redo on new action
        }

        function undo() {
            if (undoStack.length > 0) {
                redoStack.push({
                    components: JSON.parse(JSON.stringify(components)),
                    wires: JSON.parse(JSON.stringify(wires))
                });
                const state = undoStack.pop();
                components = state.components;
                wires = state.wires;
                selectedComponent = null;
                render();
                alert('‚è™ Undo');
            }
        }

        function redo() {
            if (redoStack.length > 0) {
                undoStack.push({
                    components: JSON.parse(JSON.stringify(components)),
                    wires: JSON.parse(JSON.stringify(wires))
                });
                const state = redoStack.pop();
                components = state.components;
                wires = state.wires;
                render();
                alert('‚è© Redo');
            }
        }

        function copyComponent() {
            if (selectedComponent) {
                clipboard = JSON.parse(JSON.stringify(selectedComponent));
                alert('üìã Component copied');
            }
        }

        function pasteComponent() {
            if (clipboard) {
                saveState();
                const newComp = JSON.parse(JSON.stringify(clipboard));
                newComp.id = components.length + 1;
                newComp.x += 30;
                newComp.y += 30;
                newComp.label = (newComp.label || 'Component') + ' (copy)';
                components.push(newComp);
                selectedComponent = newComp;
                render();
                alert('üìå Component pasted');
            }
        }

        function selectAllComponents() {
            // In future can add multi-select
            alert('üìç All components selectable with Shift+Click');
        }

        document.addEventListener('keydown', (e) => {
            // Ctrl+C - Copy
            if (e.ctrlKey && e.key === 'c' && !e.shiftKey) {
                if (document.activeElement.tagName !== 'INPUT' &&
                    document.activeElement.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    copyComponent();
                }
            }
            // Ctrl+V - Paste
            else if (e.ctrlKey && e.key === 'v') {
                if (document.activeElement.tagName !== 'INPUT' &&
                    document.activeElement.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    pasteComponent();
                }
            }
            // Ctrl+Z - Undo
            else if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            }
            // Ctrl+Y or Ctrl+Shift+Z - Redo
            else if ((e.ctrlKey && e.key === 'y') || (e.ctrlKey && e.shiftKey && e.key === 'z')) {
                e.preventDefault();
                redo();
            }
            // Ctrl+A - Select All
            else if (e.ctrlKey && e.key === 'a') {
                if (document.activeElement.tagName !== 'INPUT' &&
                    document.activeElement.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    selectAllComponents();
                }
            }
            // Ctrl+D - Duplicate
            else if (e.ctrlKey && e.key === 'd') {
                if (document.activeElement.tagName !== 'INPUT' &&
                    document.activeElement.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    duplicateComponent();
                }
            }
            // Delete or Backspace - Delete component
            else if (e.key === 'Delete' || e.key === 'Backspace') {
                if (document.activeElement.tagName !== 'INPUT' &&
                    document.activeElement.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    deleteComponent();
                }
            }
            // Escape - Deselect
            else if (e.key === 'Escape') {
                selectedComponent = null;
                wireStart = null;
                document.getElementById('propertiesContent').innerHTML = '<p style="color: #95a5a6; font-size: 0.85em;">Select a component to edit properties</p>';
                render();
            }
            // +/= - Zoom in
            else if (e.key === '+' || e.key === '=') {
                if (document.activeElement.tagName !== 'INPUT') {
                    e.preventDefault();
                    zoomIn();
                }
            }
            // - - Zoom out
            else if (e.key === '-' || e.key === '_') {
                if (document.activeElement.tagName !== 'INPUT') {
                    e.preventDefault();
                    zoomOut();
                }
            }
            // 0 - Reset view
            else if (e.key === '0') {
                if (document.activeElement.tagName !== 'INPUT') {
                    e.preventDefault();
                    resetView();
                }
            }
            // S - Select tool
            else if (e.key === 's' || e.key === 'S') {
                if (document.activeElement.tagName !== 'INPUT' &&
                    document.activeElement.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    setTool('select');
                }
            }
            // W - Wire tool
            else if (e.key === 'w' || e.key === 'W') {
                if (document.activeElement.tagName !== 'INPUT' &&
                    document.activeElement.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    setTool('wire');
                }
            }
        });

        // Save state on component add/delete/move (call saveState() before making changes)
        const originalPush = components.push;
        components.push = function(...args) {
            saveState();
            return originalPush.apply(this, args);
        };

        // Initialize
        render();

        // Auto-import on load if session exists
        const sessionId = new URLSearchParams(window.location.search).get('session');
        if (sessionId) {
            setTimeout(() => {
                if (confirm('Import components from previous work?')) {
                    importFromTakeoffs();
                }
            }, 500);
        }

        // Show keyboard shortcuts on load
        console.log(`
        üéπ KEYBOARD SHORTCUTS:
        - Ctrl+C: Copy component
        - Ctrl+V: Paste component
        - Ctrl+Z: Undo
        - Ctrl+Y: Redo
        - Ctrl+D: Duplicate component
        - Ctrl+A: Select all info
        - Delete/Backspace: Delete component
        - Escape: Deselect
        - +/=: Zoom in
        - -: Zoom out
        - 0: Reset view
        - S: Select tool
        - W: Wire tool
        `);
    </script>

    <!-- AI Chatbot Component -->
    {% include 'chatbot_component.html' %}
</body>
</html>
