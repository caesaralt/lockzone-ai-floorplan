<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electrical Mapping - {{ project_name | default('New Project') }}</title>
    <!-- PDF.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
    <script>
        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js';
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0e14;
            overflow: hidden;
            color: #ecf0f1;
        }

        .top-toolbar {
            background: linear-gradient(135deg, #1a252f 0%, #0f1419 100%);
            padding: 10px 20px;
            border-bottom: 2px solid #3498db;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 4px 12px rgba(0,0,0,0.6);
        }

        .toolbar-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .project-title {
            font-size: 1.2em;
            font-weight: 700;
            color: #3498db;
        }

        .toolbar-btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%);
            border: 2px solid transparent;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.3s;
            white-space: nowrap;
        }

        .toolbar-btn input[type="file"] {
            display: none;
        }

        .toolbar-btn:hover {
            background: linear-gradient(135deg, #2c3e50 0%, #1a252f 100%);
            border-color: #3498db;
            transform: translateY(-1px);
        }

        .toolbar-btn.success {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
        }

        .toolbar-btn.ai {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            background: #16213e;
            padding: 5px 12px;
            border-radius: 6px;
            border: 2px solid #2c3e50;
        }

        .zoom-btn {
            background: #2c3e50;
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .zoom-btn:hover {
            background: #34495e;
            transform: scale(1.1);
        }

        .zoom-level {
            color: #3498db;
            font-weight: 600;
            min-width: 50px;
            text-align: center;
        }

        .app-container {
            display: flex;
            height: calc(100vh - 52px);
        }

        .left-panel, .right-panel {
            width: 280px;
            background: #16213e;
            padding: 15px;
            overflow-y: auto;
            border-right: 2px solid #2c3e50;
        }

        .right-panel {
            border-right: none;
            border-left: 2px solid #2c3e50;
        }

        .panel-section {
            margin-bottom: 20px;
        }

        .panel-section h3 {
            color: #3498db;
            margin-bottom: 10px;
            font-size: 1em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }

        .layer-item, .component-btn {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            margin-bottom: 6px;
            background: #2c3e50;
            border: 2px solid transparent;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9em;
        }

        .component-btn:hover, .layer-item:hover {
            background: #34495e;
            border-color: #3498db;
            transform: translateX(4px);
        }

        .component-btn.active {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            border-color: #3498db;
        }

        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #0f1419;
            position: relative;
            overflow: hidden;
        }

        .canvas-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #mappingCanvas {
            cursor: crosshair;
            transform-origin: 0 0;
            transition: transform 0.1s ease-out;
        }

        .canvas-wrapper.panning #mappingCanvas {
            cursor: grab;
        }

        .canvas-wrapper.panning:active #mappingCanvas {
            cursor: grabbing;
        }

        .properties-panel {
            background: #2c3e50;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
        }

        .properties-panel h3 {
            color: #3498db;
            margin-bottom: 10px;
            font-size: 0.95em;
        }

        .prop-group {
            margin-bottom: 12px;
        }

        .prop-group label {
            display: block;
            color: #95a5a6;
            font-size: 0.8em;
            margin-bottom: 4px;
            font-weight: 600;
        }

        .prop-group input, .prop-group select {
            width: 100%;
            padding: 8px;
            background: #34495e;
            border: 2px solid #2c3e50;
            border-radius: 4px;
            color: white;
            font-size: 0.9em;
        }

        .prop-group input:focus, .prop-group select:focus {
            outline: none;
            border-color: #3498db;
        }

        .circuit-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .circuit-item {
            background: #34495e;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 6px;
            border-left: 4px solid #e74c3c;
        }

        .circuit-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
            gap: 8px;
        }

        .circuit-name {
            font-weight: 600;
            color: #3498db;
            flex: 1;
        }

        .circuit-actions {
            display: flex;
            gap: 5px;
        }

        .circuit-btn {
            padding: 2px 6px;
            border: none;
            color: white;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .circuit-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .circuit-btn.edit {
            background: #3498db;
        }

        .circuit-btn.delete {
            background: #e74c3c;
        }

        .circuit-info {
            font-size: 0.8em;
            color: #95a5a6;
        }

        .legend {
            margin-top: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.85em;
        }

        .legend-color {
            width: 30px;
            height: 3px;
            margin-right: 8px;
        }

        .context-menu {
            display: none;
            position: absolute;
            background: #2c3e50;
            border: 2px solid #3498db;
            border-radius: 6px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.6);
            z-index: 1000;
            min-width: 180px;
        }

        .context-menu-item {
            padding: 10px 15px;
            cursor: pointer;
            color: white;
            transition: all 0.2s;
            font-size: 0.9em;
        }

        .context-menu-item:hover {
            background: #3498db;
        }

        .ai-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(22, 33, 62, 0.95);
            padding: 30px;
            border-radius: 12px;
            border: 2px solid #9b59b6;
            text-align: center;
            z-index: 100;
            display: none;
        }

        .ai-loading.active {
            display: block;
        }

        .spinner {
            border: 4px solid rgba(155, 89, 182, 0.3);
            border-top: 4px solid #9b59b6;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="top-toolbar">
        <div class="toolbar-left">
            <div class="project-title">‚ö° {{ project_name | default('Electrical Mapping') }}</div>
            <label class="toolbar-btn">
                üìÅ Upload Floor Plan
                <input type="file" id="floorplanUpload" accept=".pdf,image/*">
            </label>
        </div>
        <div class="zoom-controls">
            <button class="zoom-btn" onclick="zoomIn()">+</button>
            <span class="zoom-level" id="zoomLevel">100%</span>
            <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
            <button class="zoom-btn" onclick="resetView()">‚ü≤</button>
        </div>
        <div>
            <button class="toolbar-btn" onclick="window.location.href='/canvas'">‚Üê Canvas</button>
            <button class="toolbar-btn" onclick="importFromTakeoffs()">üì• Import from Takeoffs</button>
            <button class="toolbar-btn ai" onclick="runAIMapping()">ü§ñ AI Mapping</button>
            <button class="toolbar-btn success" onclick="exportMapping()">üíæ Export</button>
        </div>
    </div>

    <div class="app-container">
        <!-- LEFT PANEL: Layers & Components -->
        <div class="left-panel">
            <div class="panel-section">
                <h3>üìÅ Layers</h3>
                <div class="layer-item active">
                    <span><input type="checkbox" id="layerFloorplan" class="layer-checkbox" checked> Floor Plan</span>
                </div>
                <div class="layer-item active">
                    <span><input type="checkbox" id="layerComponents" class="layer-checkbox" checked> Components</span>
                </div>
                <div class="layer-item active">
                    <span><input type="checkbox" id="layerWiring" class="layer-checkbox" checked> Wiring</span>
                </div>
                <div class="layer-item active">
                    <span><input type="checkbox" id="layerCircuits" class="layer-checkbox" checked> Circuits</span>
                </div>
                <div class="layer-item active">
                    <span><input type="checkbox" id="layerAnnotations" class="layer-checkbox" checked> Annotations</span>
                </div>
            </div>

            <div class="panel-section">
                <h3>üîß Components</h3>
                <button class="component-btn" onclick="selectComponent('light')">
                    üí° Light Fixture
                </button>
                <button class="component-btn" onclick="selectComponent('switch')">
                    üîò Switch
                </button>
                <button class="component-btn" onclick="selectComponent('outlet')">
                    ‚ö° Outlet
                </button>
                <button class="component-btn" onclick="selectComponent('panel')">
                    ‚öôÔ∏è Electrical Panel
                </button>
                <button class="component-btn" onclick="selectComponent('junction')">
                    üì¶ Junction Box
                </button>
                <button class="component-btn" onclick="selectComponent('sensor')">
                    üì° Sensor/Detector
                </button>
                <button class="component-btn" onclick="selectComponent('dimmer')">
                    üéöÔ∏è Dimmer
                </button>
                <button class="component-btn" onclick="selectComponent('fan')">
                    üåÄ Ceiling Fan
                </button>
            </div>

            <div class="panel-section">
                <h3>üõ†Ô∏è Tools</h3>
                <button class="component-btn active" id="selectTool" onclick="setTool('select')">
                    üñ±Ô∏è Select & Pan
                </button>
                <button class="component-btn" id="wireTool" onclick="setTool('wire')">
                    üîå Draw Wire
                </button>
                <button class="component-btn" id="measureTool" onclick="setTool('measure')">
                    üìè Measure
                </button>
                <button class="component-btn" id="annotateTool" onclick="setTool('annotate')">
                    üìù Annotate
                </button>
            </div>
        </div>

        <!-- CENTER: Canvas -->
        <div class="canvas-area">
            <div class="canvas-wrapper" id="canvasWrapper">
                <canvas id="mappingCanvas"></canvas>
            </div>
            <div class="ai-loading" id="aiLoading">
                <div class="spinner"></div>
                <p style="color: #9b59b6; font-weight: 600; font-size: 1.1em;">ü§ñ AI is analyzing your floor plan...</p>
                <p style="color: #95a5a6; font-size: 0.9em; margin-top: 8px;">This may take a few moments</p>
            </div>
        </div>

        <!-- RIGHT PANEL: Properties & Circuits -->
        <div class="right-panel">
            <div class="properties-panel">
                <h3>‚öôÔ∏è Properties</h3>
                <div id="propertiesContent">
                    <p style="color: #95a5a6; font-size: 0.85em;">Select a component to edit properties</p>
                </div>
            </div>

            <div class="properties-panel">
                <h3>üîå Circuits</h3>
                <button class="toolbar-btn" style="width: 100%; margin-bottom: 10px;" onclick="createCircuit()">‚ûï New Circuit</button>
                <div class="circuit-list" id="circuitList">
                    <p style="color: #95a5a6; font-size: 0.85em;">No circuits created yet</p>
                </div>
            </div>

            <div class="properties-panel">
                <h3>üìä Wire Legend</h3>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #e74c3c;"></div>
                        <span>120V Power</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #9b59b6;"></div>
                        <span>240V Power</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3498db;"></div>
                        <span>Control/Signal</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #2ecc71;"></div>
                        <span>Low Voltage</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" onclick="editComponent()">‚úèÔ∏è Edit Properties</div>
        <div class="context-menu-item" onclick="duplicateComponent()">üìã Duplicate</div>
        <div class="context-menu-item" onclick="assignCircuitToComp()">üîå Assign to Circuit</div>
        <div class="context-menu-item" onclick="deleteComponent()">üóëÔ∏è Delete</div>
    </div>

    <script>
        const canvas = document.getElementById('mappingCanvas');
        const ctx = canvas.getContext('2d');
        const canvasWrapper = document.getElementById('canvasWrapper');

        // Initialize canvas size
        canvas.width = 1400;
        canvas.height = 900;

        // Pan & Zoom state
        let panX = 0, panY = 0;
        let scale = 1;
        let isPanning = false;
        let lastPanX = 0, lastPanY = 0;

        // State
        let floorplanImage = null;
        let components = [];
        let wires = [];
        let circuits = [];
        let selectedComponent = null;
        let currentTool = 'select';
        let pendingComponentType = null;
        let wireStart = null;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let isResizing = false;
        let resizeHandle = null;
        let measureStart = null;
        let measureEnd = null;
        let annotations = [];
        let selectedWire = null;

        // Layer visibility
        let layers = {
            floorplan: true,
            components: true,
            wiring: true,
            circuits: true,
            annotations: true
        };

        // Component types configuration
        const componentConfig = {
            light: { symbol: 'üí°', color: '#FFD700', size: 20, name: 'Light Fixture', width: 40, height: 40 },
            switch: { symbol: 'üîò', color: '#4169E1', size: 16, name: 'Switch', width: 32, height: 32 },
            outlet: { symbol: '‚ö°', color: '#32CD32', size: 16, name: 'Outlet', width: 32, height: 32 },
            panel: { symbol: '‚öôÔ∏è', color: '#FF4500', size: 28, name: 'Electrical Panel', width: 56, height: 56 },
            junction: { symbol: 'üì¶', color: '#FFA500', size: 18, name: 'Junction Box', width: 36, height: 36 },
            sensor: { symbol: 'üì°', color: '#9370DB', size: 18, name: 'Sensor', width: 36, height: 36 },
            dimmer: { symbol: 'üéöÔ∏è', color: '#00CED1', size: 18, name: 'Dimmer', width: 36, height: 36 },
            fan: { symbol: 'üåÄ', color: '#4682B4', size: 22, name: 'Ceiling Fan', width: 44, height: 44 }
        };

        // Pan & Zoom Functions
        function zoomIn() {
            scale = Math.min(scale * 1.2, 5);
            updateTransform();
        }

        function zoomOut() {
            scale = Math.max(scale / 1.2, 0.2);
            updateTransform();
        }

        function resetView() {
            scale = 1;
            panX = 0;
            panY = 0;
            updateTransform();
        }

        function updateTransform() {
            canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
            document.getElementById('zoomLevel').textContent = Math.round(scale * 100) + '%';
        }

        // Layer toggle
        document.querySelectorAll('.layer-checkbox').forEach((checkbox, index) => {
            checkbox.addEventListener('change', (e) => {
                const layerNames = ['floorplan', 'components', 'wiring', 'circuits', 'annotations'];
                layers[layerNames[index]] = e.target.checked;
                render();
            });
        });

        // Render function
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Background
            ctx.fillStyle = '#f5f5f5';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw floor plan if loaded and layer is visible
            if (floorplanImage && layers.floorplan) {
                ctx.globalAlpha = 0.7;
                ctx.drawImage(floorplanImage, 0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1;
            }

            // Draw grid for precision
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;
            const gridSize = 50;
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw wires (behind components)
            if (layers.wiring) {
                wires.forEach((wire, wireIdx) => {
                    const wireColor = wire.color || (wire.type === 'power120' ? '#e74c3c' :
                                     wire.type === 'power240' ? '#9b59b6' :
                                     wire.type === 'control' ? '#3498db' : '#2ecc71');
                    ctx.strokeStyle = wireColor;
                    ctx.lineWidth = 4;
                    ctx.setLineDash([]);
                    ctx.beginPath();
                    ctx.moveTo(wire.from.x, wire.from.y);

                    // Draw with control points if they exist
                    if (wire.controlPoints && wire.controlPoints.length > 0) {
                        wire.controlPoints.forEach(pt => {
                            ctx.lineTo(pt.x, pt.y);
                        });
                    }
                    ctx.lineTo(wire.to.x, wire.to.y);
                    ctx.stroke();

                    // Draw control points as small circles
                    if (wire.controlPoints && wire.controlPoints.length > 0) {
                        wire.controlPoints.forEach((pt, idx) => {
                            ctx.fillStyle = '#3498db';
                            ctx.beginPath();
                            ctx.arc(pt.x, pt.y, 5, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        });
                    }

                    // Draw circuit label and cable type
                    const midX = wire.controlPoints && wire.controlPoints.length > 0 ?
                                wire.controlPoints[0].x : (wire.from.x + wire.to.x) / 2;
                    const midY = wire.controlPoints && wire.controlPoints.length > 0 ?
                                wire.controlPoints[0].y : (wire.from.y + wire.to.y) / 2;

                    if (wire.circuit && layers.circuits) {
                        ctx.font = 'bold 12px Arial';
                        ctx.fillStyle = '#ffffff';
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 3;
                        ctx.strokeText(`C${wire.circuit}`, midX, midY - 10);
                        ctx.fillText(`C${wire.circuit}`, midX, midY - 10);
                    }

                    if (wire.cableType) {
                        ctx.font = 'bold 10px Arial';
                        ctx.fillStyle = '#ffffff';
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        ctx.strokeText(wire.cableType, midX, midY + 10);
                        ctx.fillText(wire.cableType, midX, midY + 10);
                    }
                });
            }

            // Draw components
            if (layers.components) {
                components.forEach(comp => {
                    const config = componentConfig[comp.type] || componentConfig.light;
                    const isSelected = selectedComponent === comp;
                    const compWidth = comp.width || config.width || config.size * 2;
                    const compHeight = comp.height || config.height || config.size * 2;
                    const radius = Math.max(compWidth, compHeight) / 2;

                    // Draw background circle
                    ctx.beginPath();
                    ctx.arc(comp.x, comp.y, isSelected ? radius + 6 : radius, 0, 2 * Math.PI);
                    ctx.fillStyle = isSelected ? 'rgba(52, 152, 219, 0.3)' : 'rgba(255, 255, 255, 0.9)';
                    ctx.fill();
                    ctx.strokeStyle = config.color;
                    ctx.lineWidth = isSelected ? 4 : 3;
                    ctx.stroke();

                    // Draw symbol
                    ctx.font = `${config.size + 4}px Arial`;
                    const symbolWidth = ctx.measureText(config.symbol).width;
                    ctx.fillText(config.symbol, comp.x - symbolWidth / 2, comp.y + (config.size / 2));

                    // Draw resize handles if selected
                    if (isSelected) {
                        const handleSize = 8;
                        const handles = [
                            { x: comp.x - radius, y: comp.y - radius, type: 'nw' },
                            { x: comp.x + radius, y: comp.y - radius, type: 'ne' },
                            { x: comp.x - radius, y: comp.y + radius, type: 'sw' },
                            { x: comp.x + radius, y: comp.y + radius, type: 'se' }
                        ];

                        handles.forEach(handle => {
                            ctx.fillStyle = '#3498db';
                            ctx.fillRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
                        });
                    }

                    // Draw label
                    if (comp.label) {
                        ctx.font = 'bold 11px Arial';
                        ctx.fillStyle = '#2c3e50';
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 3;
                        ctx.strokeText(comp.label, comp.x + radius + 5, comp.y - 10);
                        ctx.fillText(comp.label, comp.x + radius + 5, comp.y - 10);
                    }

                    // Draw circuit assignment
                    if (comp.circuit && layers.circuits) {
                        ctx.font = 'bold 10px Arial';
                        ctx.fillStyle = '#f39c12';
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        ctx.strokeText(`C${comp.circuit}`, comp.x - 10, comp.y + radius + 15);
                        ctx.fillText(`C${comp.circuit}`, comp.x - 10, comp.y + radius + 15);
                    }
                });
            }

            // Draw annotations
            if (layers.annotations && annotations.length > 0) {
                annotations.forEach(ann => {
                    ctx.font = 'bold 14px Arial';
                    ctx.fillStyle = '#e74c3c';
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 3;
                    ctx.strokeText(ann.text, ann.x, ann.y);
                    ctx.fillText(ann.text, ann.x, ann.y);

                    // Draw anchor point
                    ctx.fillStyle = '#e74c3c';
                    ctx.beginPath();
                    ctx.arc(ann.x - 5, ann.y - 5, 4, 0, 2 * Math.PI);
                    ctx.fill();
                });
            }

            // Draw measure tool
            if (currentTool === 'measure' && measureStart) {
                ctx.strokeStyle = '#f39c12';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(measureStart.x, measureStart.y);
                if (measureEnd) {
                    ctx.lineTo(measureEnd.x, measureEnd.y);
                } else {
                    // Draw to current mouse position if available
                    ctx.lineTo(measureStart.x, measureStart.y);
                }
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw distance if we have both points
                if (measureEnd) {
                    const dx = measureEnd.x - measureStart.x;
                    const dy = measureEnd.y - measureStart.y;
                    const distPx = Math.sqrt(dx * dx + dy * dy);
                    const distFt = (distPx / 50).toFixed(2); // Assuming 50px = 1ft
                    const distM = (distPx / 50 * 0.3048).toFixed(2); // Convert to meters

                    const midX = (measureStart.x + measureEnd.x) / 2;
                    const midY = (measureStart.y + measureEnd.y) / 2;

                    ctx.font = 'bold 14px Arial';
                    ctx.fillStyle = '#ffffff';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 3;
                    const measureText = `${distFt} ft (${distM} m)`;
                    ctx.strokeText(measureText, midX, midY - 10);
                    ctx.fillText(measureText, midX, midY - 10);
                }
            }

            // Draw wireStart indicator when drawing wire
            if (wireStart && currentTool === 'wire') {
                ctx.fillStyle = 'rgba(52, 152, 219, 0.5)';
                ctx.beginPath();
                ctx.arc(wireStart.x, wireStart.y, 8, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        // Tool selection
        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.component-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tool + 'Tool')?.classList.add('active');

            if (tool === 'wire') {
                wireStart = null;
            } else if (tool === 'measure') {
                measureStart = null;
                measureEnd = null;
            }

            canvas.style.cursor = tool === 'select' ? 'default' : 'crosshair';
            render();
        }

        // Helper function to check if clicking on resize handle
        function getResizeHandle(comp, x, y) {
            if (!comp) return null;
            const config = componentConfig[comp.type] || componentConfig.light;
            const compWidth = comp.width || config.width || config.size * 2;
            const compHeight = comp.height || config.height || config.size * 2;
            const radius = Math.max(compWidth, compHeight) / 2;
            const handleSize = 8;
            const threshold = 10;

            const handles = [
                { x: comp.x - radius, y: comp.y - radius, type: 'nw' },
                { x: comp.x + radius, y: comp.y - radius, type: 'ne' },
                { x: comp.x - radius, y: comp.y + radius, type: 'sw' },
                { x: comp.x + radius, y: comp.y + radius, type: 'se' }
            ];

            for (let handle of handles) {
                const dx = handle.x - x;
                const dy = handle.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < threshold) {
                    return handle.type;
                }
            }
            return null;
        }

        // Helper function to get wire control point near click
        function getWireControlPoint(x, y) {
            for (let i = 0; i < wires.length; i++) {
                const wire = wires[i];
                if (wire.controlPoints && wire.controlPoints.length > 0) {
                    for (let j = 0; j < wire.controlPoints.length; j++) {
                        const pt = wire.controlPoints[j];
                        const dx = pt.x - x;
                        const dy = pt.y - y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 10) {
                            return { wireIndex: i, pointIndex: j };
                        }
                    }
                }
            }
            return null;
        }

        // Helper function to check if click is on a wire line
        function getWireAtPoint(x, y) {
            for (let i = 0; i < wires.length; i++) {
                const wire = wires[i];
                // Check distance from point to line segment
                const dist = pointToLineDistance(x, y, wire.from.x, wire.from.y, wire.to.x, wire.to.y);
                if (dist < 8) {
                    return i;
                }
            }
            return null;
        }

        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            if (lenSq != 0) param = dot / lenSq;

            let xx, yy;
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }

            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function selectComponent(type) {
            pendingComponentType = type;
            currentTool = 'place';
            canvas.style.cursor = 'crosshair';
        }

        // Mouse events
        let draggingWirePoint = null;
        let currentMouseX = 0;
        let currentMouseY = 0;

        canvasWrapper.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            if (currentTool === 'select') {
                // Check if clicking on resize handle first
                if (selectedComponent) {
                    const handle = getResizeHandle(selectedComponent, x, y);
                    if (handle) {
                        isResizing = true;
                        resizeHandle = handle;
                        return;
                    }
                }

                // Check if clicking on wire control point
                const wirePoint = getWireControlPoint(x, y);
                if (wirePoint) {
                    draggingWirePoint = wirePoint;
                    return;
                }

                // Check if clicking on component
                let clickedComp = null;
                components.forEach(comp => {
                    const config = componentConfig[comp.type] || componentConfig.light;
                    const compWidth = comp.width || config.width || config.size * 2;
                    const compHeight = comp.height || config.height || config.size * 2;
                    const radius = Math.max(compWidth, compHeight) / 2;
                    const dx = comp.x - x;
                    const dy = comp.y - y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < radius + 10) {
                        clickedComp = comp;
                    }
                });

                if (clickedComp) {
                    selectedComponent = clickedComp;
                    isDragging = true;
                    dragOffset = { x: x - clickedComp.x, y: y - clickedComp.y };
                    showProperties(clickedComp);
                    render();
                } else {
                    // Start panning
                    isPanning = true;
                    lastPanX = e.clientX;
                    lastPanY = e.clientY;
                    canvasWrapper.classList.add('panning');
                }
            } else if (currentTool === 'place' && pendingComponentType) {
                // Place component
                const config = componentConfig[pendingComponentType];
                const newComp = {
                    id: components.length + 1,
                    type: pendingComponentType,
                    x: x,
                    y: y,
                    label: `${config.name} ${components.length + 1}`,
                    circuit: null,
                    width: config.width,
                    height: config.height
                };
                components.push(newComp);
                render();
            } else if (currentTool === 'wire') {
                // Wire drawing
                if (!wireStart) {
                    // Find nearest component
                    let nearest = null;
                    let minDist = 30;
                    components.forEach(comp => {
                        const dx = comp.x - x;
                        const dy = comp.y - y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < minDist) {
                            nearest = comp;
                            minDist = dist;
                        }
                    });

                    if (nearest) {
                        wireStart = { x: nearest.x, y: nearest.y, comp: nearest };
                        render();
                    }
                } else {
                    // Check if double-clicking to add control point
                    const wireIdx = getWireAtPoint(x, y);
                    if (wireIdx !== null) {
                        if (!wires[wireIdx].controlPoints) {
                            wires[wireIdx].controlPoints = [];
                        }
                        wires[wireIdx].controlPoints.push({ x, y });
                        render();
                        return;
                    }

                    // Complete wire
                    let nearest = null;
                    let minDist = 30;
                    components.forEach(comp => {
                        if (comp !== wireStart.comp) {
                            const dx = comp.x - x;
                            const dy = comp.y - y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < minDist) {
                                nearest = comp;
                                minDist = dist;
                            }
                        }
                    });

                    if (nearest) {
                        const wireType = prompt('Wire type:\n1 = 120V Power\n2 = 240V Power\n3 = Control\n4 = Low Voltage', '1');
                        const cableType = prompt('Cable type (e.g., "14/2 Romex", "12/3 NM-B"):', '14/2 Romex');
                        const typeMap = { '1': 'power120', '2': 'power240', '3': 'control', '4': 'lowvoltage' };

                        wires.push({
                            from: { x: wireStart.x, y: wireStart.y },
                            to: { x: nearest.x, y: nearest.y },
                            type: typeMap[wireType] || 'power120',
                            cableType: cableType,
                            circuit: null,
                            controlPoints: []
                        });
                        wireStart = null;
                        render();
                    }
                }
            } else if (currentTool === 'measure') {
                if (!measureStart) {
                    measureStart = { x, y };
                } else {
                    measureEnd = { x, y };
                    render();
                    setTimeout(() => {
                        measureStart = null;
                        measureEnd = null;
                        render();
                    }, 5000); // Clear after 5 seconds
                }
            } else if (currentTool === 'annotate') {
                const text = prompt('Enter annotation text:');
                if (text) {
                    annotations.push({ x, y, text });
                    render();
                }
            }
        });

        canvasWrapper.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            currentMouseX = x;
            currentMouseY = y;

            if (isPanning) {
                const dx = e.clientX - lastPanX;
                const dy = e.clientY - lastPanY;
                panX += dx;
                panY += dy;
                lastPanX = e.clientX;
                lastPanY = e.clientY;
                updateTransform();
            } else if (isResizing && selectedComponent) {
                // Handle resizing
                const config = componentConfig[selectedComponent.type] || componentConfig.light;
                const oldWidth = selectedComponent.width || config.width;
                const oldHeight = selectedComponent.height || config.height;
                const oldRadius = Math.max(oldWidth, oldHeight) / 2;

                if (resizeHandle === 'se') {
                    const newWidth = Math.max(20, Math.abs(x - selectedComponent.x) * 2);
                    const newHeight = Math.max(20, Math.abs(y - selectedComponent.y) * 2);
                    selectedComponent.width = newWidth;
                    selectedComponent.height = newHeight;
                } else if (resizeHandle === 'sw') {
                    const newWidth = Math.max(20, Math.abs(x - selectedComponent.x) * 2);
                    const newHeight = Math.max(20, Math.abs(y - selectedComponent.y) * 2);
                    selectedComponent.width = newWidth;
                    selectedComponent.height = newHeight;
                } else if (resizeHandle === 'ne') {
                    const newWidth = Math.max(20, Math.abs(x - selectedComponent.x) * 2);
                    const newHeight = Math.max(20, Math.abs(y - selectedComponent.y) * 2);
                    selectedComponent.width = newWidth;
                    selectedComponent.height = newHeight;
                } else if (resizeHandle === 'nw') {
                    const newWidth = Math.max(20, Math.abs(x - selectedComponent.x) * 2);
                    const newHeight = Math.max(20, Math.abs(y - selectedComponent.y) * 2);
                    selectedComponent.width = newWidth;
                    selectedComponent.height = newHeight;
                }
                render();
            } else if (draggingWirePoint) {
                // Drag wire control point
                const wire = wires[draggingWirePoint.wireIndex];
                if (wire && wire.controlPoints && wire.controlPoints[draggingWirePoint.pointIndex]) {
                    wire.controlPoints[draggingWirePoint.pointIndex].x = x;
                    wire.controlPoints[draggingWirePoint.pointIndex].y = y;
                    render();
                }
            } else if (isDragging && selectedComponent) {
                selectedComponent.x = x - dragOffset.x;
                selectedComponent.y = y - dragOffset.y;
                render();
            }
        });

        canvasWrapper.addEventListener('mouseup', () => {
            isPanning = false;
            isDragging = false;
            isResizing = false;
            resizeHandle = null;
            draggingWirePoint = null;
            canvasWrapper.classList.remove('panning');
        });

        // Zoom with mouse wheel and two-finger pan support
        canvasWrapper.addEventListener('wheel', (e) => {
            e.preventDefault();

            // Two-finger pan on trackpad (shift key is set on some trackpads for horizontal scroll)
            // or when holding shift deliberately
            if (e.shiftKey || (Math.abs(e.deltaX) > Math.abs(e.deltaY))) {
                // Pan horizontally and vertically
                panX -= e.deltaX;
                panY -= e.deltaY;
                updateTransform();
            } else if (e.ctrlKey) {
                // Pinch zoom on trackpad (ctrl key typically indicates pinch gesture)
                if (e.deltaY < 0) {
                    zoomIn();
                } else {
                    zoomOut();
                }
            } else {
                // Regular scroll wheel zoom
                if (e.deltaY < 0) {
                    zoomIn();
                } else {
                    zoomOut();
                }
            }
        });

        // Right-click context menu
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            // Check if clicking on a wire
            const wireIdx = getWireAtPoint(x, y);
            if (wireIdx !== null) {
                selectedWire = wires[wireIdx];
                showWireContextMenu(e.pageX, e.pageY);
                return;
            }

            if (selectedComponent) {
                const menu = document.getElementById('contextMenu');
                menu.style.display = 'block';
                menu.style.left = e.pageX + 'px';
                menu.style.top = e.pageY + 'px';
            }
        });

        function showWireContextMenu(x, y) {
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.id = 'wireContextMenu';
            menu.style.display = 'block';
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.innerHTML = `
                <div class="context-menu-item" onclick="editWireProperties()">‚úèÔ∏è Edit Wire Properties</div>
                <div class="context-menu-item" onclick="addWireControlPoint()">‚ûï Add Bend Point</div>
                <div class="context-menu-item" onclick="deleteWire()">üóëÔ∏è Delete Wire</div>
            `;

            // Remove existing wire context menu if any
            const existing = document.getElementById('wireContextMenu');
            if (existing) existing.remove();

            document.body.appendChild(menu);
        }

        function editWireProperties() {
            if (!selectedWire) return;

            const cableType = prompt('Cable type (e.g., "14/2 Romex", "12/3 NM-B"):', selectedWire.cableType || '14/2 Romex');
            if (cableType !== null) {
                selectedWire.cableType = cableType;
            }

            const colorChoice = prompt('Wire color:\n1 = Red (120V)\n2 = Purple (240V)\n3 = Blue (Control)\n4 = Green (Low Voltage)\n5 = Custom', '1');
            const colorMap = { '1': '#e74c3c', '2': '#9b59b6', '3': '#3498db', '4': '#2ecc71' };

            if (colorChoice === '5') {
                const customColor = prompt('Enter hex color (e.g., #ff6600):', '#ff6600');
                if (customColor) {
                    selectedWire.color = customColor;
                }
            } else if (colorMap[colorChoice]) {
                selectedWire.color = colorMap[colorChoice];
            }

            // Update wire type based on color selection
            const typeMap = { '1': 'power120', '2': 'power240', '3': 'control', '4': 'lowvoltage' };
            if (typeMap[colorChoice]) {
                selectedWire.type = typeMap[colorChoice];
            }

            render();
            document.getElementById('wireContextMenu')?.remove();
        }

        function addWireControlPoint() {
            if (!selectedWire) return;

            // Add a control point at the midpoint
            const midX = (selectedWire.from.x + selectedWire.to.x) / 2;
            const midY = (selectedWire.from.y + selectedWire.to.y) / 2;

            if (!selectedWire.controlPoints) {
                selectedWire.controlPoints = [];
            }

            selectedWire.controlPoints.push({ x: midX, y: midY });
            render();
            document.getElementById('wireContextMenu')?.remove();
        }

        function deleteWire() {
            if (!selectedWire) return;

            if (confirm('Delete this wire?')) {
                const index = wires.indexOf(selectedWire);
                if (index > -1) {
                    wires.splice(index, 1);
                }
                selectedWire = null;
                render();
            }
            document.getElementById('wireContextMenu')?.remove();
        }

        document.addEventListener('click', () => {
            document.getElementById('contextMenu').style.display = 'none';
            document.getElementById('wireContextMenu')?.remove();
        });

        // Properties panel
        function showProperties(comp) {
            const config = componentConfig[comp.type];
            document.getElementById('propertiesContent').innerHTML = `
                <div class="prop-group">
                    <label>Type</label>
                    <select id="propType" onchange="updateComponentProp('type', this.value)">
                        ${Object.keys(componentConfig).map(key =>
                            `<option value="${key}" ${comp.type === key ? 'selected' : ''}>${componentConfig[key].name}</option>`
                        ).join('')}
                    </select>
                </div>
                <div class="prop-group">
                    <label>Label</label>
                    <input type="text" id="propLabel" value="${comp.label || ''}" onchange="updateComponentProp('label', this.value)">
                </div>
                <div class="prop-group">
                    <label>Circuit</label>
                    <select id="propCircuit" onchange="updateComponentProp('circuit', this.value)">
                        <option value="">Unassigned</option>
                        ${circuits.map(c => `<option value="${c.number}" ${comp.circuit == c.number ? 'selected' : ''}>Circuit ${c.number}</option>`).join('')}
                    </select>
                </div>
                <div class="prop-group">
                    <label>Position</label>
                    <input type="text" value="X: ${Math.round(comp.x)}, Y: ${Math.round(comp.y)}" readonly>
                </div>
            `;
        }

        function updateComponentProp(prop, value) {
            if (selectedComponent) {
                selectedComponent[prop] = value === '' ? null : value;
                render();
                showProperties(selectedComponent);
            }
        }

        // Context menu functions
        function editComponent() {
            if (selectedComponent) {
                showProperties(selectedComponent);
            }
        }

        function duplicateComponent() {
            if (selectedComponent) {
                const newComp = {
                    ...selectedComponent,
                    id: components.length + 1,
                    x: selectedComponent.x + 30,
                    y: selectedComponent.y + 30,
                    label: selectedComponent.label + ' (copy)'
                };
                components.push(newComp);
                selectedComponent = newComp;
                render();
            }
        }

        function assignCircuitToComp() {
            if (selectedComponent && circuits.length > 0) {
                const circuitNum = prompt(`Assign to circuit (1-${circuits.length}):`);
                if (circuitNum && circuits.find(c => c.number == circuitNum)) {
                    selectedComponent.circuit = parseInt(circuitNum);
                    render();
                    showProperties(selectedComponent);
                    updateCircuitList();
                }
            } else if (circuits.length === 0) {
                alert('Create a circuit first!');
            }
        }

        function deleteComponent() {
            if (selectedComponent && confirm('Delete this component?')) {
                components = components.filter(c => c !== selectedComponent);
                selectedComponent = null;
                document.getElementById('propertiesContent').innerHTML = '<p style="color: #95a5a6; font-size: 0.85em;">Select a component to edit properties</p>';
                render();
            }
        }

        // Circuit management
        function createCircuit() {
            const name = prompt('Circuit name:', `Circuit ${circuits.length + 1}`);
            if (name) {
                const amperage = prompt('Amperage (A):', '15');
                const voltage = prompt('Voltage (V):', '120');

                circuits.push({
                    number: circuits.length + 1,
                    name: name,
                    amperage: parseInt(amperage) || 15,
                    voltage: parseInt(voltage) || 120
                });
                updateCircuitList();
            }
        }

        function updateCircuitList() {
            const list = document.getElementById('circuitList');
            list.innerHTML = '';

            if (circuits.length === 0) {
                list.innerHTML = '<p style="color: #95a5a6; font-size: 0.85em;">No circuits created yet</p>';
                return;
            }

            const circuitMap = {};
            components.forEach(comp => {
                if (comp.circuit) {
                    if (!circuitMap[comp.circuit]) circuitMap[comp.circuit] = [];
                    circuitMap[comp.circuit].push(comp);
                }
            });

            circuits.forEach((circuit, idx) => {
                const div = document.createElement('div');
                div.className = 'circuit-item';
                div.style.position = 'relative';
                div.innerHTML = `
                    <div class="circuit-header">
                        <span class="circuit-name">${circuit.name}</span>
                        <div class="circuit-actions">
                            <button onclick="editCircuit(${idx})" class="circuit-btn edit">‚úèÔ∏è</button>
                            <button onclick="deleteCircuit(${idx})" class="circuit-btn delete">üóëÔ∏è</button>
                        </div>
                    </div>
                    <div class="circuit-info">${circuit.voltage}V, ${circuit.amperage}A</div>
                    <div class="circuit-info">${circuitMap[circuit.number]?.length || 0} component(s)</div>
                `;
                list.appendChild(div);
            });
        }

        function editCircuit(index) {
            const circuit = circuits[index];
            if (!circuit) return;

            const newName = prompt('Circuit name:', circuit.name);
            if (newName !== null && newName !== '') {
                circuit.name = newName;
            }

            const newAmperage = prompt('Amperage (A):', circuit.amperage);
            if (newAmperage !== null && newAmperage !== '') {
                circuit.amperage = parseInt(newAmperage) || circuit.amperage;
            }

            const newVoltage = prompt('Voltage (V):', circuit.voltage);
            if (newVoltage !== null && newVoltage !== '') {
                circuit.voltage = parseInt(newVoltage) || circuit.voltage;
            }

            const colorChoice = prompt('Circuit color:\n1 = Red\n2 = Purple\n3 = Blue\n4 = Green', '1');
            const colorMap = { '1': '#e74c3c', '2': '#9b59b6', '3': '#3498db', '4': '#2ecc71' };
            if (colorChoice && colorMap[colorChoice]) {
                circuit.color = colorMap[colorChoice];
            }

            updateCircuitList();
            render();
        }

        function deleteCircuit(index) {
            const circuit = circuits[index];
            if (!circuit) return;

            if (confirm(`Delete circuit "${circuit.name}"? Components will be unassigned.`)) {
                // Unassign components from this circuit
                components.forEach(comp => {
                    if (comp.circuit === circuit.number) {
                        comp.circuit = null;
                    }
                });

                // Unassign wires from this circuit
                wires.forEach(wire => {
                    if (wire.circuit === circuit.number) {
                        wire.circuit = null;
                    }
                });

                circuits.splice(index, 1);

                // Renumber remaining circuits
                circuits.forEach((c, i) => {
                    const oldNumber = c.number;
                    c.number = i + 1;

                    // Update component references
                    components.forEach(comp => {
                        if (comp.circuit === oldNumber) {
                            comp.circuit = c.number;
                        }
                    });

                    // Update wire references
                    wires.forEach(wire => {
                        if (wire.circuit === oldNumber) {
                            wire.circuit = c.number;
                        }
                    });
                });

                updateCircuitList();
                render();
            }
        }

        // Floor plan upload with PDF support
        document.getElementById('floorplanUpload').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            if (file.type === 'application/pdf') {
                // Handle PDF using PDF.js
                const fileReader = new FileReader();
                fileReader.onload = async function(event) {
                    try {
                        const typedarray = new Uint8Array(event.target.result);
                        const pdf = await pdfjsLib.getDocument(typedarray).promise;

                        // Get first page
                        const page = await pdf.getPage(1);
                        const viewport = page.getViewport({ scale: 3.5 });

                        // Create temporary canvas to render PDF
                        const tempCanvas = document.createElement('canvas');
                        const tempContext = tempCanvas.getContext('2d');
                        tempCanvas.width = viewport.width;
                        tempCanvas.height = viewport.height;

                        // Render PDF page to canvas
                        await page.render({
                            canvasContext: tempContext,
                            viewport: viewport
                        }).promise;

                        // Convert canvas to image
                        const img = new Image();
                        img.onload = function() {
                            floorplanImage = img;
                            render();
                            alert('‚úÖ PDF loaded successfully!');
                        };
                        img.src = tempCanvas.toDataURL();
                    } catch (error) {
                        console.error('PDF loading error:', error);
                        alert('Failed to load PDF: ' + error.message);
                    }
                };
                fileReader.readAsArrayBuffer(file);
            } else {
                // Handle image files
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        floorplanImage = img;
                        render();
                        alert('‚úÖ Image loaded successfully!');
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // Import from takeoffs
        function importFromTakeoffs() {
            const sessionId = new URLSearchParams(window.location.search).get('session');
            if (!sessionId) {
                alert('No session found. Please export from Canvas/Takeoffs first.');
                return;
            }

            fetch('/api/session/' + sessionId)
                .then(r => r.json())
                .then(data => {
                    if (data.symbols) {
                        components = data.symbols.map((sym, i) => ({
                            id: i + 1,
                            type: sym.automation_category || sym.type || 'light',
                            x: sym.x * canvas.width,
                            y: sym.y * canvas.height,
                            label: sym.label || sym.id,
                            circuit: null
                        }));

                        // Load floorplan if available
                        if (data.floorplan_image) {
                            const img = new Image();
                            img.onload = function() {
                                floorplanImage = img;
                                render();
                            };
                            img.src = '/static/uploads/' + data.floorplan_image;
                        }

                        render();
                        alert(`‚úÖ Imported ${components.length} components from takeoffs!`);
                    }
                })
                .catch(err => {
                    console.error('Import failed:', err);
                    alert('Failed to import from takeoffs');
                });
        }

        // AI Mapping
        async function runAIMapping() {
            if (!floorplanImage) {
                alert('Please upload a floor plan first!');
                return;
            }

            if (!confirm('Run AI analysis to automatically place electrical components? This will replace any existing components.')) {
                return;
            }

            const aiLoading = document.getElementById('aiLoading');
            aiLoading.classList.add('active');

            try {
                // Convert canvas to blob
                const imageData = canvas.toDataURL('image/jpeg', 0.9);

                const response = await fetch('/api/ai/mapping', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        floor_plan_image: imageData,
                        canvas_width: canvas.width,
                        canvas_height: canvas.height
                    })
                });

                const data = await response.json();

                if (data.success && data.components) {
                    components = data.components;
                    render();
                    alert(`‚úÖ AI placed ${components.length} electrical components!`);
                } else {
                    alert('AI mapping failed: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('AI mapping error:', error);
                alert('Failed to run AI mapping: ' + error.message);
            } finally {
                aiLoading.classList.remove('active');
            }
        }

        // Export mapping as PDF
        async function exportMapping() {
            if (components.length === 0 && wires.length === 0) {
                alert('Add some components or wires first!');
                return;
            }

            try {
                // Load jsPDF library dynamically
                if (typeof window.jspdf === 'undefined') {
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
                    document.head.appendChild(script);
                    await new Promise((resolve, reject) => {
                        script.onload = resolve;
                        script.onerror = reject;
                    });
                }

                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('landscape', 'mm', 'a4');

                // Add title
                pdf.setFontSize(20);
                pdf.text('Electrical Mapping Plan', 148, 15, { align: 'center' });

                // Convert canvas to image and add to PDF
                const canvasImage = canvas.toDataURL('image/jpeg', 0.95);
                pdf.addImage(canvasImage, 'JPEG', 10, 25, 277, 160);

                // Add legend on the right side
                let legendY = 190;
                pdf.setFontSize(14);
                pdf.text('Legend', 10, legendY);
                legendY += 7;

                // Component types legend
                pdf.setFontSize(10);
                pdf.text('Components:', 10, legendY);
                legendY += 5;

                Object.keys(componentConfig).forEach(key => {
                    const config = componentConfig[key];
                    pdf.setDrawColor(0);
                    pdf.setFillColor(config.color);
                    pdf.circle(12, legendY - 1, 1.5, 'F');
                    pdf.text(config.name, 17, legendY);
                    legendY += 4;
                });

                // Wire types legend
                legendY += 3;
                pdf.text('Wire Types:', 10, legendY);
                legendY += 5;

                const wireTypes = [
                    { name: '120V Power', color: '#e74c3c' },
                    { name: '240V Power', color: '#9b59b6' },
                    { name: 'Control/Signal', color: '#3498db' },
                    { name: 'Low Voltage', color: '#2ecc71' }
                ];

                wireTypes.forEach(wt => {
                    const rgb = hexToRgb(wt.color);
                    pdf.setDrawColor(rgb.r, rgb.g, rgb.b);
                    pdf.setLineWidth(1);
                    pdf.line(10, legendY - 1, 15, legendY - 1);
                    pdf.setDrawColor(0);
                    pdf.text(wt.name, 17, legendY);
                    legendY += 4;
                });

                // Circuits legend
                if (circuits.length > 0) {
                    legendY += 3;
                    pdf.text('Circuits:', 100, 190);
                    let circuitY = 195;

                    circuits.forEach(circuit => {
                        const circuitColor = circuit.color || '#e74c3c';
                        const rgb = hexToRgb(circuitColor);
                        pdf.setFillColor(rgb.r, rgb.g, rgb.b);
                        pdf.circle(102, circuitY - 1, 1.5, 'F');
                        pdf.setDrawColor(0);
                        pdf.setFontSize(9);
                        pdf.text(`${circuit.name} - ${circuit.voltage}V, ${circuit.amperage}A`, 107, circuitY);
                        circuitY += 4;
                    });
                }

                // Add metadata
                pdf.setFontSize(8);
                pdf.text(`Generated: ${new Date().toLocaleString()}`, 10, 205);
                pdf.text(`Components: ${components.length} | Wires: ${wires.length} | Circuits: ${circuits.length}`, 10, 209);

                // Save the PDF
                const filename = `electrical-mapping-${Date.now()}.pdf`;
                pdf.save(filename);

                alert('‚úÖ PDF exported successfully!');
            } catch (error) {
                console.error('Export error:', error);
                alert('Failed to export PDF: ' + error.message);
            }
        }

        // Helper function to convert hex to RGB
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        // Keyboard Shortcuts
        let clipboard = null;  // For copy/paste
        let undoStack = [];
        let redoStack = [];

        function saveState() {
            undoStack.push({
                components: JSON.parse(JSON.stringify(components)),
                wires: JSON.parse(JSON.stringify(wires))
            });
            // Limit undo stack size
            if (undoStack.length > 50) undoStack.shift();
            redoStack = [];  // Clear redo on new action
        }

        function undo() {
            if (undoStack.length > 0) {
                redoStack.push({
                    components: JSON.parse(JSON.stringify(components)),
                    wires: JSON.parse(JSON.stringify(wires))
                });
                const state = undoStack.pop();
                components = state.components;
                wires = state.wires;
                selectedComponent = null;
                render();
                alert('‚è™ Undo');
            }
        }

        function redo() {
            if (redoStack.length > 0) {
                undoStack.push({
                    components: JSON.parse(JSON.stringify(components)),
                    wires: JSON.parse(JSON.stringify(wires))
                });
                const state = redoStack.pop();
                components = state.components;
                wires = state.wires;
                render();
                alert('‚è© Redo');
            }
        }

        function copyComponent() {
            if (selectedComponent) {
                clipboard = JSON.parse(JSON.stringify(selectedComponent));
                alert('üìã Component copied');
            }
        }

        function pasteComponent() {
            if (clipboard) {
                saveState();
                const newComp = JSON.parse(JSON.stringify(clipboard));
                newComp.id = components.length + 1;
                newComp.x += 30;
                newComp.y += 30;
                newComp.label = (newComp.label || 'Component') + ' (copy)';
                components.push(newComp);
                selectedComponent = newComp;
                render();
                alert('üìå Component pasted');
            }
        }

        function selectAllComponents() {
            // In future can add multi-select
            alert('üìç All components selectable with Shift+Click');
        }

        document.addEventListener('keydown', (e) => {
            // Ctrl+C - Copy
            if (e.ctrlKey && e.key === 'c' && !e.shiftKey) {
                if (document.activeElement.tagName !== 'INPUT' &&
                    document.activeElement.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    copyComponent();
                }
            }
            // Ctrl+V - Paste
            else if (e.ctrlKey && e.key === 'v') {
                if (document.activeElement.tagName !== 'INPUT' &&
                    document.activeElement.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    pasteComponent();
                }
            }
            // Ctrl+Z - Undo
            else if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            }
            // Ctrl+Y or Ctrl+Shift+Z - Redo
            else if ((e.ctrlKey && e.key === 'y') || (e.ctrlKey && e.shiftKey && e.key === 'z')) {
                e.preventDefault();
                redo();
            }
            // Ctrl+A - Select All
            else if (e.ctrlKey && e.key === 'a') {
                if (document.activeElement.tagName !== 'INPUT' &&
                    document.activeElement.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    selectAllComponents();
                }
            }
            // Ctrl+D - Duplicate
            else if (e.ctrlKey && e.key === 'd') {
                if (document.activeElement.tagName !== 'INPUT' &&
                    document.activeElement.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    duplicateComponent();
                }
            }
            // Delete or Backspace - Delete component
            else if (e.key === 'Delete' || e.key === 'Backspace') {
                if (document.activeElement.tagName !== 'INPUT' &&
                    document.activeElement.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    deleteComponent();
                }
            }
            // Escape - Deselect
            else if (e.key === 'Escape') {
                selectedComponent = null;
                wireStart = null;
                document.getElementById('propertiesContent').innerHTML = '<p style="color: #95a5a6; font-size: 0.85em;">Select a component to edit properties</p>';
                render();
            }
            // +/= - Zoom in
            else if (e.key === '+' || e.key === '=') {
                if (document.activeElement.tagName !== 'INPUT') {
                    e.preventDefault();
                    zoomIn();
                }
            }
            // - - Zoom out
            else if (e.key === '-' || e.key === '_') {
                if (document.activeElement.tagName !== 'INPUT') {
                    e.preventDefault();
                    zoomOut();
                }
            }
            // 0 - Reset view
            else if (e.key === '0') {
                if (document.activeElement.tagName !== 'INPUT') {
                    e.preventDefault();
                    resetView();
                }
            }
            // S - Select tool
            else if (e.key === 's' || e.key === 'S') {
                if (document.activeElement.tagName !== 'INPUT' &&
                    document.activeElement.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    setTool('select');
                }
            }
            // W - Wire tool
            else if (e.key === 'w' || e.key === 'W') {
                if (document.activeElement.tagName !== 'INPUT' &&
                    document.activeElement.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    setTool('wire');
                }
            }
            // M - Measure tool
            else if (e.key === 'm' || e.key === 'M') {
                if (document.activeElement.tagName !== 'INPUT' &&
                    document.activeElement.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    setTool('measure');
                }
            }
            // A - Annotate tool
            else if (e.key === 'a' || e.key === 'A') {
                if (document.activeElement.tagName !== 'INPUT' &&
                    document.activeElement.tagName !== 'TEXTAREA' &&
                    !e.ctrlKey) {
                    e.preventDefault();
                    setTool('annotate');
                }
            }
        });

        // Save state on component add/delete/move (call saveState() before making changes)
        const originalPush = components.push;
        components.push = function(...args) {
            saveState();
            return originalPush.apply(this, args);
        };

        // Initialize
        render();

        // Auto-import on load if session exists
        const sessionId = new URLSearchParams(window.location.search).get('session');
        if (sessionId) {
            setTimeout(() => {
                if (confirm('Import components from previous work?')) {
                    importFromTakeoffs();
                }
            }, 500);
        }

        // Show keyboard shortcuts on load
        console.log(`
        üéπ KEYBOARD SHORTCUTS:
        - Ctrl+C: Copy component
        - Ctrl+V: Paste component
        - Ctrl+Z: Undo
        - Ctrl+Y: Redo
        - Ctrl+D: Duplicate component
        - Ctrl+A: Select all info
        - Delete/Backspace: Delete component
        - Escape: Deselect
        - +/=: Zoom in
        - -: Zoom out
        - 0: Reset view
        - S: Select tool
        - W: Wire tool
        - M: Measure tool
        - A: Annotate tool

        üñ±Ô∏è MOUSE CONTROLS:
        - Scroll wheel: Zoom in/out
        - Shift + Scroll: Pan (two-finger trackpad pan)
        - Click + Drag: Pan canvas or move component
        - Right-click component: Context menu
        - Right-click wire: Wire properties menu
        `);
    </script>

    <!-- AI Chatbot Component -->
    {% include 'chatbot_component.html' %}
</body>
</html>
